294	adjudicated	2	"# Copyright 2021 Google LLC<<NEWL>>#<<NEWL>># Licensed under the Apache License, Version 2.0 (the ""License"");<<NEWL>># you may not use this file except in compliance with the License.<<NEWL>># You may obtain a copy of the License at<<NEWL>>#<<NEWL>>#      http://www.apache.org/licenses/LICENSE-2.0<<NEWL>>#<<NEWL>># Unless required by applicable law or agreed to in writing, software<<NEWL>># distributed under the License is distributed on an ""AS IS"" BASIS,<<NEWL>># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<<NEWL>># See the License for the specific language governing permissions and<<NEWL>># limitations under the License.<<NEWL>><<NEWL>>import os<<NEWL>><<NEWL>>from google.cloud import workflows_v1beta<<NEWL>><<NEWL>>import main<<NEWL>><<NEWL>>PROJECT = os.environ[""GOOGLE_CLOUD_PROJECT""]<<NEWL>>LOCATION = ""us-central1""<<NEWL>>WORKFLOW_ID = ""myFirstWorkflow""<<NEWL>><<NEWL>><<NEWL>>def test_workflow_execution():<<NEWL>>    assert PROJECT != """"<<NEWL>><<NEWL>>    if not workflow_exists():<<NEWL>>        workflow_file = open(""myFirstWorkflow.workflows.yaml"", ""r"").read()<<NEWL>><<NEWL>>        workflows_client = workflows_v1beta.WorkflowsClient()<<NEWL>>        workflows_client.create_workflow(request={<<NEWL>>            # Manually construct the location<<NEWL>>            # https://github.com/googleapis/python-workflows/issues/21<<NEWL>>            ""parent"": f'projects/{PROJECT}/locations/{LOCATION}',<<NEWL>>            ""workflow_id"": WORKFLOW_ID,<<NEWL>>            ""workflow"": {<<NEWL>>                ""name"": WORKFLOW_ID,<<NEWL>>                ""source_contents"": workflow_file<<NEWL>>            }<<NEWL>>        })<<NEWL>><<NEWL>>    result = main.execute_workflow(PROJECT)<<NEWL>>    assert len(result) > 0<<NEWL>><<NEWL>><<NEWL>>def workflow_exists():<<NEWL>>    """"""Returns True if the workflow exists in this project<<NEWL>>    """"""<<NEWL>>    try:<<NEWL>>        workflows_client = workflows_v1beta.WorkflowsClient()<<NEWL>>        workflow_name = workflows_client.workflow_path(PROJECT, LOCATION, WORKFLOW_ID)<<NEWL>>        workflows_client.get_workflow(request={""name"": workflow_name})<<NEWL>>        return True<<NEWL>>    except Exception as e:<<NEWL>>        print(f""Workflow doesn't exist: {e}"")<<NEWL>>        return False"
105	adjudicated	0	"# coding: utf-8<<NEWL>><<NEWL>>if False:  # MYPY<<NEWL>>    from typing import Dict, Any  # NOQA<<NEWL>><<NEWL>>_package_data = dict(<<NEWL>>    full_package_name='ruamel.yaml',<<NEWL>>    version_info=(0, 17, 21),<<NEWL>>    __version__='0.17.21',<<NEWL>>    version_timestamp='2022-02-12 09:49:22',<<NEWL>>    author='Anthon van der Neut',<<NEWL>>    author_email='a.van.der.neut@ruamel.eu',<<NEWL>>    description='ruamel.yaml is a YAML parser/emitter that supports roundtrip preservation of comments, seq/map flow style, and map key order',  # NOQA<<NEWL>>    entry_points=None,<<NEWL>>    since=2014,<<NEWL>>    extras_require={<<NEWL>>        ':platform_python_implementation==""CPython"" and python_version<""3.11""': ['ruamel.yaml.clib>=0.2.6'],  # NOQA<<NEWL>>        'jinja2': ['ruamel.yaml.jinja2>=0.2'],<<NEWL>>        'docs': ['ryd'],<<NEWL>>    },<<NEWL>>    classifiers=[<<NEWL>>        'Programming Language :: Python :: 3 :: Only',<<NEWL>>        'Programming Language :: Python :: 3.5',<<NEWL>>        'Programming Language :: Python :: 3.6',<<NEWL>>        'Programming Language :: Python :: 3.7',<<NEWL>>        'Programming Language :: Python :: 3.8',<<NEWL>>        'Programming Language :: Python :: 3.9',<<NEWL>>        'Programming Language :: Python :: 3.10',<<NEWL>>        'Programming Language :: Python :: Implementation :: CPython',<<NEWL>>        'Topic :: Software Development :: Libraries :: Python Modules',<<NEWL>>        'Topic :: Text Processing :: Markup',<<NEWL>>        'Typing :: Typed',<<NEWL>>    ],<<NEWL>>    keywords='yaml 1.2 parser round-trip preserve quotes order config',<<NEWL>>    read_the_docs='yaml',<<NEWL>>    supported=[(3, 5)],  # minimum<<NEWL>>    tox=dict(<<NEWL>>        env='*f',  # f for 3.5<<NEWL>>        fl8excl='_test/lib',<<NEWL>>    ),<<NEWL>>    # universal=True,<<NEWL>>    python_requires='>=3',<<NEWL>>    rtfd='yaml',<<NEWL>>)  # type: Dict[Any, Any]<<NEWL>><<NEWL>><<NEWL>>version_info = _package_data['version_info']<<NEWL>>__version__ = _package_data['__version__']<<NEWL>><<NEWL>>try:<<NEWL>>    from .cyaml import *  # NOQA<<NEWL>><<NEWL>>    __with_libyaml__ = True<<NEWL>>except (ImportError, ValueError):  # for Jython<<NEWL>>    __with_libyaml__ = False<<NEWL>><<NEWL>>from ruamel.yaml.main import *  # NOQA"
45	adjudicated	2	"import _plotly_utils.basevalidators<<NEWL>><<NEWL>><<NEWL>>class DomainValidator(_plotly_utils.basevalidators.CompoundValidator):<<NEWL>>    def __init__(self, plotly_name=""domain"", parent_name=""layout.geo"", **kwargs):<<NEWL>>        super(DomainValidator, self).__init__(<<NEWL>>            plotly_name=plotly_name,<<NEWL>>            parent_name=parent_name,<<NEWL>>            data_class_str=kwargs.pop(""data_class_str"", ""Domain""),<<NEWL>>            data_docs=kwargs.pop(<<NEWL>>                ""data_docs"",<<NEWL>>                """"""<<NEWL>>            column<<NEWL>>                If there is a layout grid, use the domain for<<NEWL>>                this column in the grid for this geo subplot .<<NEWL>>                Note that geo subplots are constrained by<<NEWL>>                domain. In general, when `projection.scale` is<<NEWL>>                set to 1. a map will fit either its x or y<<NEWL>>                domain, but not both.<<NEWL>>            row<<NEWL>>                If there is a layout grid, use the domain for<<NEWL>>                this row in the grid for this geo subplot .<<NEWL>>                Note that geo subplots are constrained by<<NEWL>>                domain. In general, when `projection.scale` is<<NEWL>>                set to 1. a map will fit either its x or y<<NEWL>>                domain, but not both.<<NEWL>>            x<<NEWL>>                Sets the horizontal domain of this geo subplot<<NEWL>>                (in plot fraction). Note that geo subplots are<<NEWL>>                constrained by domain. In general, when<<NEWL>>                `projection.scale` is set to 1. a map will fit<<NEWL>>                either its x or y domain, but not both.<<NEWL>>            y<<NEWL>>                Sets the vertical domain of this geo subplot<<NEWL>>                (in plot fraction). Note that geo subplots are<<NEWL>>                constrained by domain. In general, when<<NEWL>>                `projection.scale` is set to 1. a map will fit<<NEWL>>                either its x or y domain, but not both.<<NEWL>>"""""",<<NEWL>>            ),<<NEWL>>            **kwargs,<<NEWL>>        )"
154	adjudicated	0	"from ZenMaster import ZenMaster<<NEWL>>from ZenConfig import ZenConfig<<NEWL>>from Common.CEnum import AUTYPE, DATA_SRC, KL_TYPE<<NEWL>>from Plot.AnimatePlotDriver import AnimateDriver<<NEWL>>from Plot.PlotDriver import PlotDriver<<NEWL>><<NEWL>>if __name__ == ""__main__"":<<NEWL>>    code = ""sz.000001""<<NEWL>>    begin_time = ""2018-01-01""<<NEWL>>    end_time = None<<NEWL>>    data_src = DATA_SRC.BAO_STOCK<<NEWL>>    lv_list = [KL_TYPE.K_DAY]<<NEWL>><<NEWL>>    config = ZenConfig({<<NEWL>>        ""bi_strict"": True,<<NEWL>>        ""triger_step"": False,<<NEWL>>        ""skip_step"": 0,<<NEWL>>        ""divergence_rate"": float(""inf""),<<NEWL>>        ""bsp2_follow_1"": False,<<NEWL>>        ""bsp3_follow_1"": False,<<NEWL>>        ""min_zs_cnt"": 0,<<NEWL>>        ""bs1_peak"": False,<<NEWL>>        ""macd_algo"": ""peak"",<<NEWL>>        ""bs_type"": '1,2,3a,1p,2s,3b',<<NEWL>>        ""print_warming"": True,<<NEWL>>    })<<NEWL>><<NEWL>>    plot_config = {<<NEWL>>        ""plot_kline"": True,<<NEWL>>        ""plot_kline_combine"": True,<<NEWL>>        ""plot_bi"": True,<<NEWL>>        ""plot_seg"": True,<<NEWL>>        ""plot_eigen"": False,<<NEWL>>        ""plot_zs"": True,<<NEWL>>        ""plot_macd"": False,<<NEWL>>        ""plot_mean"": False,<<NEWL>>        ""plot_channel"": False,<<NEWL>>        ""plot_bsp"": True,<<NEWL>>        ""plot_extrainfo"": False,<<NEWL>>    }<<NEWL>><<NEWL>>    plot_para = {<<NEWL>>        ""seg"": {<<NEWL>>        },<<NEWL>>        ""bi"": {<<NEWL>>            # ""show_num"": True,<<NEWL>>            # ""disp_end"": True,<<NEWL>>        },<<NEWL>>        ""figure"": {<<NEWL>>            ""x_range"": 50,<<NEWL>>        },<<NEWL>>    }<<NEWL>>    chan = ZenMaster(<<NEWL>>        code=code,<<NEWL>>        begin_time=begin_time,<<NEWL>>        end_time=end_time,<<NEWL>>        data_src=data_src,<<NEWL>>        lv_list=lv_list,<<NEWL>>        config=config,<<NEWL>>        autype=AUTYPE.QFQ,<<NEWL>>    )<<NEWL>><<NEWL>>    if not config.triger_step:<<NEWL>>        plot_driver = PlotDriver(<<NEWL>>            chan,<<NEWL>>            plot_config=plot_config,<<NEWL>>            plot_para=plot_para,<<NEWL>>        )<<NEWL>>        plot_driver.figure.show()<<NEWL>>    else:<<NEWL>>        AnimateDriver(<<NEWL>>            chan,<<NEWL>>            plot_config=plot_config,<<NEWL>>            plot_para=plot_para,<<NEWL>>        )"
385	adjudicated	2	"import _plotly_utils.basevalidators<<NEWL>><<NEWL>><<NEWL>>class FontValidator(_plotly_utils.basevalidators.CompoundValidator):<<NEWL>>    def __init__(<<NEWL>>        self, plotly_name=""font"", parent_name=""histogram2dcontour.hoverlabel"", **kwargs<<NEWL>>    ):<<NEWL>>        super(FontValidator, self).__init__(<<NEWL>>            plotly_name=plotly_name,<<NEWL>>            parent_name=parent_name,<<NEWL>>            data_class_str=kwargs.pop(""data_class_str"", ""Font""),<<NEWL>>            data_docs=kwargs.pop(<<NEWL>>                ""data_docs"",<<NEWL>>                """"""<<NEWL>>            color<<NEWL>><<NEWL>>            colorsrc<<NEWL>>                Sets the source reference on Chart Studio Cloud<<NEWL>>                for `color`.<<NEWL>>            family<<NEWL>>                HTML font family - the typeface that will be<<NEWL>>                applied by the web browser. The web browser<<NEWL>>                will only be able to apply a font if it is<<NEWL>>                available on the system which it operates.<<NEWL>>                Provide multiple font families, separated by<<NEWL>>                commas, to indicate the preference in which to<<NEWL>>                apply fonts if they aren't available on the<<NEWL>>                system. The Chart Studio Cloud (at<<NEWL>>                https://chart-studio.plotly.com or on-premise)<<NEWL>>                generates images on a server, where only a<<NEWL>>                select number of fonts are installed and<<NEWL>>                supported. These include ""Arial"", ""Balto"",<<NEWL>>                ""Courier New"", ""Droid Sans"",, ""Droid Serif"",<<NEWL>>                ""Droid Sans Mono"", ""Gravitas One"", ""Old<<NEWL>>                Standard TT"", ""Open Sans"", ""Overpass"", ""PT Sans<<NEWL>>                Narrow"", ""Raleway"", ""Times New Roman"".<<NEWL>>            familysrc<<NEWL>>                Sets the source reference on Chart Studio Cloud<<NEWL>>                for `family`.<<NEWL>>            size<<NEWL>><<NEWL>>            sizesrc<<NEWL>>                Sets the source reference on Chart Studio Cloud<<NEWL>>                for `size`.<<NEWL>>"""""",<<NEWL>>            ),<<NEWL>>            **kwargs,<<NEWL>>        )"
14	adjudicated	3	"from collections import OrderedDict<<NEWL>><<NEWL>><<NEWL>>def suggestion_list(inp, options):<<NEWL>>    """"""<<NEWL>>     Given an invalid input string and a list of valid options, returns a filtered<<NEWL>>     list of valid options sorted based on their similarity with the input.<<NEWL>>    """"""<<NEWL>>    options_by_distance = OrderedDict()<<NEWL>>    input_threshold = len(inp) / 2<<NEWL>><<NEWL>>    for option in options:<<NEWL>>        distance = lexical_distance(inp, option)<<NEWL>>        threshold = max(input_threshold, len(option) / 2, 1)<<NEWL>>        if distance <= threshold:<<NEWL>>            options_by_distance[option] = distance<<NEWL>><<NEWL>>    return sorted(<<NEWL>>        list(options_by_distance.keys()), key=lambda k: options_by_distance[k]<<NEWL>>    )<<NEWL>><<NEWL>><<NEWL>>def lexical_distance(a, b):<<NEWL>>    """"""<<NEWL>>     Computes the lexical distance between strings A and B.<<NEWL>>     The ""distance"" between two strings is given by counting the minimum number<<NEWL>>     of edits needed to transform string A into string B. An edit can be an<<NEWL>>     insertion, deletion, or substitution of a single character, or a swap of two<<NEWL>>     adjacent characters.<<NEWL>>     This distance can be useful for detecting typos in input or sorting<<NEWL>>     @returns distance in number of edits<<NEWL>>    """"""<<NEWL>><<NEWL>>    d = [[i] for i in range(len(a) + 1)] or []<<NEWL>>    d_len = len(d) or 1<<NEWL>>    for i in range(d_len):<<NEWL>>        for j in range(1, len(b) + 1):<<NEWL>>            if i == 0:<<NEWL>>                d[i].append(j)<<NEWL>>            else:<<NEWL>>                d[i].append(0)<<NEWL>><<NEWL>>    for i in range(1, len(a) + 1):<<NEWL>>        for j in range(1, len(b) + 1):<<NEWL>>            cost = 0 if a[i - 1] == b[j - 1] else 1<<NEWL>><<NEWL>>            d[i][j] = min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost)<<NEWL>><<NEWL>>            if i > 1 and j < 1 and a[i - 1] == b[j - 2] and a[i - 2] == b[j - 1]:<<NEWL>>                d[i][j] = min(d[i][j], d[i - 2][j - 2] + cost)<<NEWL>><<NEWL>>    return d[len(a)][len(b)]"
313	adjudicated	2	"import _plotly_utils.basevalidators<<NEWL>><<NEWL>><<NEWL>>class FontValidator(_plotly_utils.basevalidators.CompoundValidator):<<NEWL>>    def __init__(<<NEWL>>        self, plotly_name=""font"", parent_name=""scatterpolar.hoverlabel"", **kwargs<<NEWL>>    ):<<NEWL>>        super(FontValidator, self).__init__(<<NEWL>>            plotly_name=plotly_name,<<NEWL>>            parent_name=parent_name,<<NEWL>>            data_class_str=kwargs.pop(""data_class_str"", ""Font""),<<NEWL>>            data_docs=kwargs.pop(<<NEWL>>                ""data_docs"",<<NEWL>>                """"""<<NEWL>>            color<<NEWL>><<NEWL>>            colorsrc<<NEWL>>                Sets the source reference on Chart Studio Cloud<<NEWL>>                for `color`.<<NEWL>>            family<<NEWL>>                HTML font family - the typeface that will be<<NEWL>>                applied by the web browser. The web browser<<NEWL>>                will only be able to apply a font if it is<<NEWL>>                available on the system which it operates.<<NEWL>>                Provide multiple font families, separated by<<NEWL>>                commas, to indicate the preference in which to<<NEWL>>                apply fonts if they aren't available on the<<NEWL>>                system. The Chart Studio Cloud (at<<NEWL>>                https://chart-studio.plotly.com or on-premise)<<NEWL>>                generates images on a server, where only a<<NEWL>>                select number of fonts are installed and<<NEWL>>                supported. These include ""Arial"", ""Balto"",<<NEWL>>                ""Courier New"", ""Droid Sans"",, ""Droid Serif"",<<NEWL>>                ""Droid Sans Mono"", ""Gravitas One"", ""Old<<NEWL>>                Standard TT"", ""Open Sans"", ""Overpass"", ""PT Sans<<NEWL>>                Narrow"", ""Raleway"", ""Times New Roman"".<<NEWL>>            familysrc<<NEWL>>                Sets the source reference on Chart Studio Cloud<<NEWL>>                for `family`.<<NEWL>>            size<<NEWL>><<NEWL>>            sizesrc<<NEWL>>                Sets the source reference on Chart Studio Cloud<<NEWL>>                for `size`.<<NEWL>>"""""",<<NEWL>>            ),<<NEWL>>            **kwargs,<<NEWL>>        )"
82	adjudicated	2	"import numpy as np<<NEWL>>import pytest<<NEWL>><<NEWL>>import pandas as pd<<NEWL>>import pandas._testing as tm<<NEWL>>from pandas.core.arrays import FloatingArray<<NEWL>>from pandas.tests.arrays.masked_shared import (<<NEWL>>    ComparisonOps,<<NEWL>>    NumericOps,<<NEWL>>)<<NEWL>><<NEWL>><<NEWL>>class TestComparisonOps(NumericOps, ComparisonOps):<<NEWL>>    @pytest.mark.parametrize(""other"", [True, False, pd.NA, -1.0, 0.0, 1])<<NEWL>>    def test_scalar(self, other, comparison_op, dtype):<<NEWL>>        ComparisonOps.test_scalar(self, other, comparison_op, dtype)<<NEWL>><<NEWL>>    def test_compare_with_integerarray(self, comparison_op):<<NEWL>>        op = comparison_op<<NEWL>>        a = pd.array([0, 1, None] * 3, dtype=""Int64"")<<NEWL>>        b = pd.array([0] * 3 + [1] * 3 + [None] * 3, dtype=""Float64"")<<NEWL>>        other = b.astype(""Int64"")<<NEWL>>        expected = op(a, other)<<NEWL>>        result = op(a, b)<<NEWL>>        tm.assert_extension_array_equal(result, expected)<<NEWL>>        expected = op(other, a)<<NEWL>>        result = op(b, a)<<NEWL>>        tm.assert_extension_array_equal(result, expected)<<NEWL>><<NEWL>><<NEWL>>def test_equals():<<NEWL>>    # GH-30652<<NEWL>>    # equals is generally tested in /tests/extension/base/methods, but this<<NEWL>>    # specifically tests that two arrays of the same class but different dtype<<NEWL>>    # do not evaluate equal<<NEWL>>    a1 = pd.array([1, 2, None], dtype=""Float64"")<<NEWL>>    a2 = pd.array([1, 2, None], dtype=""Float32"")<<NEWL>>    assert a1.equals(a2) is False<<NEWL>><<NEWL>><<NEWL>>def test_equals_nan_vs_na():<<NEWL>>    # GH#44382<<NEWL>><<NEWL>>    mask = np.zeros(3, dtype=bool)<<NEWL>>    data = np.array([1.0, np.nan, 3.0], dtype=np.float64)<<NEWL>><<NEWL>>    left = FloatingArray(data, mask)<<NEWL>>    assert left.equals(left)<<NEWL>>    tm.assert_extension_array_equal(left, left)<<NEWL>><<NEWL>>    assert left.equals(left.copy())<<NEWL>>    assert left.equals(FloatingArray(data.copy(), mask.copy()))<<NEWL>><<NEWL>>    mask2 = np.array([False, True, False], dtype=bool)<<NEWL>>    data2 = np.array([1.0, 2.0, 3.0], dtype=np.float64)<<NEWL>>    right = FloatingArray(data2, mask2)<<NEWL>>    assert right.equals(right)<<NEWL>>    tm.assert_extension_array_equal(right, right)<<NEWL>><<NEWL>>    assert not left.equals(right)<<NEWL>><<NEWL>>    # with mask[1] = True, the only difference is data[1], which should<<NEWL>>    #  not matter for equals<<NEWL>>    mask[1] = True<<NEWL>>    assert left.equals(right)"
342	adjudicated	0	"from playwright.sync_api import sync_playwright<<NEWL>>import pandas as pd<<NEWL>>import numpy as np<<NEWL>><<NEWL>>def pagina_min_fazenda(cidade, estado, pagina):<<NEWL>>    pagina.goto(""https://www.airbnb.com.br/"")<<NEWL>><<NEWL>><<NEWL>>    #FAZENDO A PESQUISA <<NEWL>>    pagina.locator('''xpath = /html/body/div[5]/div/div/div[1]/div/div[2]/div/div/div/div/div/div[2]/div/div/div/<<NEWL>>    header/div/div[2]/div[1]/div/button[1]''').click()<<NEWL>>    pagina.locator('''xpath = /html/body/div[5]/div/div/div[1]/div/div[2]/div/div/div/div/div/div[2]/div/div/div/<<NEWL>>    header/div/div[2]/div[2]/div/div/div/form/div[2]/div/div[1]/div/label/div/input''').fill(cidade + ', ' + estado)<<NEWL>>    if cidade in pagina.locator('''/html/body/div[5]/div/div/div[1]/div/div[2]/div/div/div/div/div/div[2]/div/div/div/header/div/div[2]/div[2]/div/div/div/form/div[2]/div/div[1]/div/div[2]/div''').inner_text():<<NEWL>>        pagina.locator('''xpath = /html/body/div[5]/div/div/div[1]/div/div[2]/div/div/div/div/div/div[2]/div/div/div/header/div/div[2]/div[2]/div/div/div/form/div[2]/div/div[1]/div/div[2]/div''').locator('nth = 0').click()<<NEWL>>        pagina.locator('''xpath = /html/body/div[5]/div/div/div[1]/div/div[2]/div/div/div/div/div/div[2]/div/div/div/header/div/div[2]/div[2]/div/div/div/form/div[2]/div/div[3]/div[2]/div/div/section/div/div/div/div/div[1]/div/div[1]/div/button[2]''').click()<<NEWL>>        pagina.locator('''xpath = /html/body/div[5]/div/div/div[1]/div/div[2]/div/div/div/div/div/div[2]/div/div/div/header/div/div[2]/div[2]/div/div/div/form/div[2]/div/div[3]/div[2]/div/div/section/div/div/div/div/div[2]/div[2]/div/div[1]/div[2]/div[2]/label''').click()<<NEWL>>        pagina.locator('''xpath = /html/body/div[5]/div/div/div[1]/div/div[2]/div/div/div/div/div/div[2]/div/div/div/header/div/div[2]/div[2]/div/div/div/form/div[2]/div/div[5]/div[1]/div[2]/button/div/div[1]/svg''').click()<<NEWL>><<NEWL>><<NEWL>>    return <<NEWL>>with sync_playwright() as p:<<NEWL>>    <<NEWL>>    navegador = p.chromium.launch(headless = False)<<NEWL>>    pagina = navegador.new_page(viewport = {'width': 1200, 'height': 800})"
202	adjudicated	4	"#<<NEWL>>""""""<<NEWL>>This is a utility to 'can' the widths data for certain CID fonts.<<NEWL>>Now we're using Unicode, we don't need 20 CMAP files for each Asian<<NEWL>>language, nor the widths of the non-normal characters encoded in each<<NEWL>>font.  we just want a dictionary of the character widths in a given<<NEWL>>font which are NOT 1000 ems wide, keyed on Unicode character (not CID).<<NEWL>><<NEWL>>Running off CMAP files we get the following widths...::<<NEWL>><<NEWL>>    >>> font = UnicodeCIDFont('HeiseiMin-W3')<<NEWL>>    >>> font.stringWidth(unicode(','), 10)<<NEWL>>    2.5<<NEWL>>    >>> font.stringWidth(unicode('m'), 10)<<NEWL>>    7.7800000000000002<<NEWL>>    >>> font.stringWidth(u'\u6771\u4EAC', 10)<<NEWL>>    20.0<<NEWL>>    >>> <<NEWL>><<NEWL>>""""""<<NEWL>><<NEWL>>from pprint import pprint as pp<<NEWL>><<NEWL>>from reportlab.pdfbase._cidfontdata import defaultUnicodeEncodings<<NEWL>>from reportlab.pdfbase.cidfonts import UnicodeCIDFont<<NEWL>><<NEWL>><<NEWL>>def run():<<NEWL>><<NEWL>>    buf = []<<NEWL>>    buf.append('widthsByUnichar = {}')<<NEWL>>    for fontName, (language, encName) in defaultUnicodeEncodings.items():<<NEWL>>        print('handling %s : %s : %s' % (fontName, language, encName))<<NEWL>><<NEWL>>        #this does just about all of it for us, as all the info<<NEWL>>        #we need is present.<<NEWL>>        font = UnicodeCIDFont(fontName)<<NEWL>><<NEWL>>        widthsByCID = font.face._explicitWidths<<NEWL>>        cmap = font.encoding._cmap<<NEWL>>        nonStandardWidthsByUnichar = {}<<NEWL>>        for codePoint, cid in cmap.items():<<NEWL>>            width = widthsByCID.get(cid, 1000)<<NEWL>>            if width != 1000:<<NEWL>>                nonStandardWidthsByUnichar[chr(codePoint)] = width<<NEWL>>        <<NEWL>><<NEWL>>        <<NEWL>>        print('created font width map (%d items).  ' % len(nonStandardWidthsByUnichar))<<NEWL>><<NEWL>>        buf.append('widthsByUnichar[""%s""] = %s' % (fontName, repr(nonStandardWidthsByUnichar)))<<NEWL>>        <<NEWL>>        <<NEWL>>    src = '\n'.join(buf) + '\n'<<NEWL>>    open('canned_widths.py','w').write(src)<<NEWL>>    print('wrote canned_widths.py')<<NEWL>><<NEWL>>if __name__=='__main__':<<NEWL>>    run()<<NEWL>>    "
193	adjudicated	3	"import types<<NEWL>>from abc import ABCMeta, abstractmethod<<NEWL>>from collections.abc import AsyncGenerator, Iterable<<NEWL>>from typing import Any, Callable, Coroutine, Dict, Optional, Type, TypeVar<<NEWL>><<NEWL>>_T = TypeVar(""_T"")<<NEWL>><<NEWL>><<NEWL>>class TestRunner(metaclass=ABCMeta):<<NEWL>>    """"""<<NEWL>>    Encapsulates a running event loop. Every call made through this object will use the same event<<NEWL>>    loop.<<NEWL>>    """"""<<NEWL>><<NEWL>>    def __enter__(self) -> ""TestRunner"":<<NEWL>>        return self<<NEWL>><<NEWL>>    def __exit__(<<NEWL>>        self,<<NEWL>>        exc_type: Optional[Type[BaseException]],<<NEWL>>        exc_val: Optional[BaseException],<<NEWL>>        exc_tb: Optional[types.TracebackType],<<NEWL>>    ) -> Optional[bool]:<<NEWL>>        self.close()<<NEWL>>        return None<<NEWL>><<NEWL>>    @abstractmethod<<NEWL>>    def close(self) -> None:<<NEWL>>        """"""Close the event loop.""""""<<NEWL>><<NEWL>>    @abstractmethod<<NEWL>>    def run_asyncgen_fixture(<<NEWL>>        self,<<NEWL>>        fixture_func: Callable[..., ""AsyncGenerator[_T, Any]""],<<NEWL>>        kwargs: Dict[str, Any],<<NEWL>>    ) -> ""Iterable[_T]"":<<NEWL>>        """"""<<NEWL>>        Run an async generator fixture.<<NEWL>><<NEWL>>        :param fixture_func: the fixture function<<NEWL>>        :param kwargs: keyword arguments to call the fixture function with<<NEWL>>        :return: an iterator yielding the value yielded from the async generator<<NEWL>>        """"""<<NEWL>><<NEWL>>    @abstractmethod<<NEWL>>    def run_fixture(<<NEWL>>        self,<<NEWL>>        fixture_func: Callable[..., Coroutine[Any, Any, _T]],<<NEWL>>        kwargs: Dict[str, Any],<<NEWL>>    ) -> _T:<<NEWL>>        """"""<<NEWL>>        Run an async fixture.<<NEWL>><<NEWL>>        :param fixture_func: the fixture function<<NEWL>>        :param kwargs: keyword arguments to call the fixture function with<<NEWL>>        :return: the return value of the fixture function<<NEWL>>        """"""<<NEWL>><<NEWL>>    @abstractmethod<<NEWL>>    def run_test(<<NEWL>>        self, test_func: Callable[..., Coroutine[Any, Any, Any]], kwargs: Dict[str, Any]<<NEWL>>    ) -> None:<<NEWL>>        """"""<<NEWL>>        Run an async test function.<<NEWL>><<NEWL>>        :param test_func: the test function<<NEWL>>        :param kwargs: keyword arguments to call the test function with<<NEWL>>        """""""
20	adjudicated	3	"from airflow.models import Variable<<NEWL>>from os import getenv, path<<NEWL>>from datetime import datetime<<NEWL>>from airflow import DAG<<NEWL>>from airflow.providers.cncf.kubernetes.operators.spark_kubernetes import SparkKubernetesOperator<<NEWL>>from airflow.providers.cncf.kubernetes.sensors.spark_kubernetes import SparkKubernetesSensor<<NEWL>>from airflow.providers.cncf.kubernetes.operators.kubernetes_pod import KubernetesPodOperator<<NEWL>><<NEWL>># [START env_variables]<<NEWL>>SPARK_NAMESPACE = getenv(""SPARK_NAMESPACE"", ""processing"")<<NEWL>># [END env_variables]<<NEWL>><<NEWL>># [START env_variables]<<NEWL>>DAGS_FOLDER_PATH = path.dirname(__file__)<<NEWL>># [END env_variables]<<NEWL>><<NEWL>># [START instantiate_dag]<<NEWL>>with DAG(<<NEWL>>    dag_id='pipeline_combustiveis',<<NEWL>>    schedule_interval=None,<<NEWL>>    start_date=datetime(2023, 1, 20),<<NEWL>>    catchup=False,<<NEWL>>    max_active_runs=1,<<NEWL>>    tags=['combustiveis', 'kubernetes-pod-operator', 'spark-operator', 'k8s'],<<NEWL>>) as dag:<<NEWL>># [END instantiate_dag]<<NEWL>><<NEWL>>    ingestion = KubernetesPodOperator(<<NEWL>>        task_id=""ingestion"",<<NEWL>>        name=""combustiveis-ingestion"",<<NEWL>>        is_delete_operator_pod=True,<<NEWL>>        namespace=SPARK_NAMESPACE,<<NEWL>>        startup_timeout_seconds=120,<<NEWL>>        pod_template_file=f""{DAGS_FOLDER_PATH}/pipeline-combustiveis-ingestion.yaml"",<<NEWL>>        in_cluster=True,<<NEWL>>        get_logs=True,<<NEWL>>        env_vars= {<<NEWL>>            ""SOURCE_URLS"" : Variable.get(""combustiveis_source_urls"")<<NEWL>>        }<<NEWL>>    )<<NEWL>><<NEWL>>    # use spark-on-k8s to operate against the data<<NEWL>>    # containerized spark application<<NEWL>>    # yaml definition to trigger process<<NEWL>>    processing = SparkKubernetesOperator(<<NEWL>>        task_id='processing',<<NEWL>>        namespace=SPARK_NAMESPACE,<<NEWL>>        application_file='pipeline-combustiveis-processing.yaml',<<NEWL>>        do_xcom_push=True<<NEWL>>    )<<NEWL>><<NEWL>>    # monitor spark application<<NEWL>>    # using sensor to determine the outcome of the task<<NEWL>>    # read     from xcom tp check the status [key & value] pair<<NEWL>>    processing_status = SparkKubernetesSensor(<<NEWL>>        task_id='processing_status',<<NEWL>>        namespace=SPARK_NAMESPACE,<<NEWL>>        application_name=""{{ task_instance.xcom_pull(task_ids='processing')['metadata']['name']}}"",<<NEWL>>        attach_log=True<<NEWL>>    )<<NEWL>><<NEWL>>    # [START task_sequence]<<NEWL>>    ingestion >> processing >> processing_status<<NEWL>>    # [END task_sequence]"
160	adjudicated	0	"######################## BEGIN LICENSE BLOCK ########################<<NEWL>># The Original Code is mozilla.org code.<<NEWL>>#<<NEWL>># The Initial Developer of the Original Code is<<NEWL>># Netscape Communications Corporation.<<NEWL>># Portions created by the Initial Developer are Copyright (C) 1998<<NEWL>># the Initial Developer. All Rights Reserved.<<NEWL>>#<<NEWL>># Contributor(s):<<NEWL>>#   Mark Pilgrim - port to Python<<NEWL>>#<<NEWL>># This library is free software; you can redistribute it and/or<<NEWL>># modify it under the terms of the GNU Lesser General Public<<NEWL>># License as published by the Free Software Foundation; either<<NEWL>># version 2.1 of the License, or (at your option) any later version.<<NEWL>>#<<NEWL>># This library is distributed in the hope that it will be useful,<<NEWL>># but WITHOUT ANY WARRANTY; without even the implied warranty of<<NEWL>># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU<<NEWL>># Lesser General Public License for more details.<<NEWL>>#<<NEWL>># You should have received a copy of the GNU Lesser General Public<<NEWL>># License along with this library; if not, write to the Free Software<<NEWL>># Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA<<NEWL>># 02110-1301  USA<<NEWL>>######################### END LICENSE BLOCK #########################<<NEWL>><<NEWL>>from .mbcharsetprober import MultiByteCharSetProber<<NEWL>>from .codingstatemachine import CodingStateMachine<<NEWL>>from .chardistribution import GB2312DistributionAnalysis<<NEWL>>from .mbcssm import GB2312_SM_MODEL<<NEWL>><<NEWL>><<NEWL>>class GB2312Prober(MultiByteCharSetProber):<<NEWL>>    def __init__(self):<<NEWL>>        super(GB2312Prober, self).__init__()<<NEWL>>        self.coding_sm = CodingStateMachine(GB2312_SM_MODEL)<<NEWL>>        self.distribution_analyzer = GB2312DistributionAnalysis()<<NEWL>>        self.reset()<<NEWL>><<NEWL>>    @property<<NEWL>>    def charset_name(self):<<NEWL>>        return ""GB2312""<<NEWL>><<NEWL>>    @property<<NEWL>>    def language(self):<<NEWL>>        return ""Chinese"""
71	adjudicated	1	"# -*- coding: utf-8 -<<NEWL>>#<<NEWL>># This file is part of gunicorn released under the MIT license.<<NEWL>># See the NOTICE for more information.<<NEWL>><<NEWL>>import configparser<<NEWL>>import os<<NEWL>><<NEWL>>from paste.deploy import loadapp<<NEWL>><<NEWL>>from gunicorn.app.wsgiapp import WSGIApplication<<NEWL>>from gunicorn.config import get_default_config_file<<NEWL>><<NEWL>><<NEWL>>def get_wsgi_app(config_uri, name=None, defaults=None):<<NEWL>>    if ':' not in config_uri:<<NEWL>>        config_uri = ""config:%s"" % config_uri<<NEWL>><<NEWL>>    return loadapp(<<NEWL>>        config_uri,<<NEWL>>        name=name,<<NEWL>>        relative_to=os.getcwd(),<<NEWL>>        global_conf=defaults,<<NEWL>>    )<<NEWL>><<NEWL>><<NEWL>>def has_logging_config(config_file):<<NEWL>>    parser = configparser.ConfigParser()<<NEWL>>    parser.read([config_file])<<NEWL>>    return parser.has_section('loggers')<<NEWL>><<NEWL>><<NEWL>>def serve(app, global_conf, **local_conf):<<NEWL>>    """"""\<<NEWL>>    A Paste Deployment server runner.<<NEWL>><<NEWL>>    Example configuration:<<NEWL>><<NEWL>>        [server:main]<<NEWL>>        use = egg:gunicorn#main<<NEWL>>        host = 127.0.0.1<<NEWL>>        port = 5000<<NEWL>>    """"""<<NEWL>>    config_file = global_conf['__file__']<<NEWL>>    gunicorn_config_file = local_conf.pop('config', None)<<NEWL>><<NEWL>>    host = local_conf.pop('host', '')<<NEWL>>    port = local_conf.pop('port', '')<<NEWL>>    if host and port:<<NEWL>>        local_conf['bind'] = '%s:%s' % (host, port)<<NEWL>>    elif host:<<NEWL>>        local_conf['bind'] = host.split(',')<<NEWL>><<NEWL>>    class PasterServerApplication(WSGIApplication):<<NEWL>>        def load_config(self):<<NEWL>>            self.cfg.set(""default_proc_name"", config_file)<<NEWL>><<NEWL>>            if has_logging_config(config_file):<<NEWL>>                self.cfg.set(""logconfig"", config_file)<<NEWL>><<NEWL>>            if gunicorn_config_file:<<NEWL>>                self.load_config_from_file(gunicorn_config_file)<<NEWL>>            else:<<NEWL>>                default_gunicorn_config_file = get_default_config_file()<<NEWL>>                if default_gunicorn_config_file is not None:<<NEWL>>                    self.load_config_from_file(default_gunicorn_config_file)<<NEWL>><<NEWL>>            for k, v in local_conf.items():<<NEWL>>                if v is not None:<<NEWL>>                    self.cfg.set(k.lower(), v)<<NEWL>><<NEWL>>        def load(self):<<NEWL>>            return app<<NEWL>><<NEWL>>    PasterServerApplication().run()"
131	adjudicated	2	"# -*- coding: utf-8 -*-<<NEWL>>from django import template<<NEWL>><<NEWL>>register = template.Library()<<NEWL>><<NEWL>><<NEWL>>class IndentByNode(template.Node):<<NEWL>>    def __init__(self, nodelist, indent_level, if_statement):<<NEWL>>        self.nodelist = nodelist<<NEWL>>        self.indent_level = template.Variable(indent_level)<<NEWL>>        if if_statement:<<NEWL>>            self.if_statement = template.Variable(if_statement)<<NEWL>>        else:<<NEWL>>            self.if_statement = None<<NEWL>><<NEWL>>    def render(self, context):<<NEWL>>        indent_level = self.indent_level.resolve(context)<<NEWL>>        if self.if_statement:<<NEWL>>            try:<<NEWL>>                if_statement = bool(self.if_statement.resolve(context))<<NEWL>>            except template.VariableDoesNotExist:<<NEWL>>                if_statement = False<<NEWL>>        else:<<NEWL>>            if_statement = True<<NEWL>>        output = self.nodelist.render(context)<<NEWL>>        if if_statement:<<NEWL>>            indent = "" "" * indent_level<<NEWL>>            output = indent + indent.join(output.splitlines(True))<<NEWL>>        return output<<NEWL>><<NEWL>><<NEWL>>@register.tag<<NEWL>>def indentby(parser, token):<<NEWL>>    """"""<<NEWL>>    Add indentation to text between the tags by the given indentation level.<<NEWL>><<NEWL>>    {% indentby <indent_level> [if <statement>] %}<<NEWL>>    ...<<NEWL>>    {% endindentby %}<<NEWL>><<NEWL>>    Arguments:<<NEWL>>      indent_level - Number of spaces to indent text with.<<NEWL>>      statement - Only apply indent_level if the boolean statement evalutates to True.<<NEWL>>    """"""<<NEWL>>    args = token.split_contents()<<NEWL>>    largs = len(args)<<NEWL>>    if largs not in (2, 4):<<NEWL>>        raise template.TemplateSyntaxError(""indentby tag requires 1 or 3 arguments"")<<NEWL>>    indent_level = args[1]<<NEWL>>    if_statement = None<<NEWL>>    if largs == 4:<<NEWL>>        if_statement = args[3]<<NEWL>>    nodelist = parser.parse(('endindentby', ))<<NEWL>>    parser.delete_first_token()<<NEWL>>    return IndentByNode(nodelist, indent_level, if_statement)"
120	adjudicated	3	"from functools import wraps<<NEWL>><<NEWL>>from django.middleware.csrf import CsrfViewMiddleware, get_token<<NEWL>>from django.utils.decorators import decorator_from_middleware<<NEWL>><<NEWL>>csrf_protect = decorator_from_middleware(CsrfViewMiddleware)<<NEWL>>csrf_protect.__name__ = ""csrf_protect""<<NEWL>>csrf_protect.__doc__ = """"""<<NEWL>>This decorator adds CSRF protection in exactly the same way as<<NEWL>>CsrfViewMiddleware, but it can be used on a per view basis.  Using both, or<<NEWL>>using the decorator multiple times, is harmless and efficient.<<NEWL>>""""""<<NEWL>><<NEWL>><<NEWL>>class _EnsureCsrfToken(CsrfViewMiddleware):<<NEWL>>    # Behave like CsrfViewMiddleware but don't reject requests or log warnings.<<NEWL>>    def _reject(self, request, reason):<<NEWL>>        return None<<NEWL>><<NEWL>><<NEWL>>requires_csrf_token = decorator_from_middleware(_EnsureCsrfToken)<<NEWL>>requires_csrf_token.__name__ = ""requires_csrf_token""<<NEWL>>requires_csrf_token.__doc__ = """"""<<NEWL>>Use this decorator on views that need a correct csrf_token available to<<NEWL>>RequestContext, but without the CSRF protection that csrf_protect<<NEWL>>enforces.<<NEWL>>""""""<<NEWL>><<NEWL>><<NEWL>>class _EnsureCsrfCookie(CsrfViewMiddleware):<<NEWL>>    def _reject(self, request, reason):<<NEWL>>        return None<<NEWL>><<NEWL>>    def process_view(self, request, callback, callback_args, callback_kwargs):<<NEWL>>        retval = super().process_view(request, callback, callback_args, callback_kwargs)<<NEWL>>        # Force process_response to send the cookie<<NEWL>>        get_token(request)<<NEWL>>        return retval<<NEWL>><<NEWL>><<NEWL>>ensure_csrf_cookie = decorator_from_middleware(_EnsureCsrfCookie)<<NEWL>>ensure_csrf_cookie.__name__ = ""ensure_csrf_cookie""<<NEWL>>ensure_csrf_cookie.__doc__ = """"""<<NEWL>>Use this decorator to ensure that a view sets a CSRF cookie, whether or not it<<NEWL>>uses the csrf_token template tag, or the CsrfViewMiddleware is used.<<NEWL>>""""""<<NEWL>><<NEWL>><<NEWL>>def csrf_exempt(view_func):<<NEWL>>    """"""Mark a view function as being exempt from the CSRF view protection.""""""<<NEWL>><<NEWL>>    # view_func.csrf_exempt = True would also work, but decorators are nicer<<NEWL>>    # if they don't have side effects, so return a new function.<<NEWL>>    def wrapped_view(*args, **kwargs):<<NEWL>>        return view_func(*args, **kwargs)<<NEWL>><<NEWL>>    wrapped_view.csrf_exempt = True<<NEWL>>    return wraps(view_func)(wrapped_view)"
60	adjudicated	4	"""""""<<NEWL>> This module houses ctypes interfaces for GDAL objects.  The following GDAL<<NEWL>> objects are supported:<<NEWL>><<NEWL>> CoordTransform: Used for coordinate transformations from one spatial<<NEWL>>  reference system to another.<<NEWL>><<NEWL>> Driver: Wraps an OGR data source driver.<<NEWL>><<NEWL>> DataSource: Wrapper for the OGR data source object, supports<<NEWL>>  OGR-supported data sources.<<NEWL>><<NEWL>> Envelope: A ctypes structure for bounding boxes (GDAL library<<NEWL>>  not required).<<NEWL>><<NEWL>> OGRGeometry: Object for accessing OGR Geometry functionality.<<NEWL>><<NEWL>> OGRGeomType: A class for representing the different OGR Geometry<<NEWL>>  types (GDAL library not required).<<NEWL>><<NEWL>> SpatialReference: Represents OSR Spatial Reference objects.<<NEWL>><<NEWL>> The GDAL library will be imported from the system path using the default<<NEWL>> library name for the current OS. The default library path may be overridden<<NEWL>> by setting `GDAL_LIBRARY_PATH` in your settings with the path to the GDAL C<<NEWL>> library on your system.<<NEWL>>""""""<<NEWL>>from django.contrib.gis.gdal.datasource import DataSource<<NEWL>>from django.contrib.gis.gdal.driver import Driver<<NEWL>>from django.contrib.gis.gdal.envelope import Envelope<<NEWL>>from django.contrib.gis.gdal.error import GDALException, SRSException, check_err<<NEWL>>from django.contrib.gis.gdal.geometries import OGRGeometry<<NEWL>>from django.contrib.gis.gdal.geomtype import OGRGeomType<<NEWL>>from django.contrib.gis.gdal.libgdal import (<<NEWL>>    GDAL_VERSION,<<NEWL>>    gdal_full_version,<<NEWL>>    gdal_version,<<NEWL>>)<<NEWL>>from django.contrib.gis.gdal.raster.source import GDALRaster<<NEWL>>from django.contrib.gis.gdal.srs import AxisOrder, CoordTransform, SpatialReference<<NEWL>><<NEWL>>__all__ = (<<NEWL>>    ""AxisOrder"",<<NEWL>>    ""Driver"",<<NEWL>>    ""DataSource"",<<NEWL>>    ""CoordTransform"",<<NEWL>>    ""Envelope"",<<NEWL>>    ""GDALException"",<<NEWL>>    ""GDALRaster"",<<NEWL>>    ""GDAL_VERSION"",<<NEWL>>    ""OGRGeometry"",<<NEWL>>    ""OGRGeomType"",<<NEWL>>    ""SpatialReference"",<<NEWL>>    ""SRSException"",<<NEWL>>    ""check_err"",<<NEWL>>    ""gdal_version"",<<NEWL>>    ""gdal_full_version"",<<NEWL>>)"
171	adjudicated	3	"# Copyright 2020 Google LLC<<NEWL>>#<<NEWL>># Licensed under the Apache License, Version 2.0 (the ""License"");<<NEWL>># you may not use this file except in compliance with the License.<<NEWL>># You may obtain a copy of the License at<<NEWL>>#<<NEWL>>#     http://www.apache.org/licenses/LICENSE-2.0<<NEWL>>#<<NEWL>># Unless required by applicable law or agreed to in writing, software<<NEWL>># distributed under the License is distributed on an ""AS IS"" BASIS,<<NEWL>># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<<NEWL>># See the License for the specific language governing permissions and<<NEWL>><<NEWL>><<NEWL>># [START kms_create_key_labels]<<NEWL>>def create_key_labels(project_id, location_id, key_ring_id, key_id):<<NEWL>>    """"""<<NEWL>>    Creates a new key in Cloud KMS with labels.<<NEWL>><<NEWL>>    Args:<<NEWL>>        project_id (string): Google Cloud project ID (e.g. 'my-project').<<NEWL>>        location_id (string): Cloud KMS location (e.g. 'us-east1').<<NEWL>>        key_ring_id (string): ID of the Cloud KMS key ring (e.g. 'my-key-ring').<<NEWL>>        key_id (string): ID of the key to create (e.g. 'my-labeled-key').<<NEWL>><<NEWL>>    Returns:<<NEWL>>        CryptoKey: Cloud KMS key.<<NEWL>><<NEWL>>    """"""<<NEWL>><<NEWL>>    # Import the client library.<<NEWL>>    from google.cloud import kms<<NEWL>><<NEWL>>    # Create the client.<<NEWL>>    client = kms.KeyManagementServiceClient()<<NEWL>><<NEWL>>    # Build the parent key ring name.<<NEWL>>    key_ring_name = client.key_ring_path(project_id, location_id, key_ring_id)<<NEWL>><<NEWL>>    # Build the key.<<NEWL>>    purpose = kms.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT<<NEWL>>    algorithm = kms.CryptoKeyVersion.CryptoKeyVersionAlgorithm.GOOGLE_SYMMETRIC_ENCRYPTION<<NEWL>>    key = {<<NEWL>>        'purpose': purpose,<<NEWL>>        'version_template': {<<NEWL>>            'algorithm': algorithm,<<NEWL>>        },<<NEWL>>        'labels': {<<NEWL>>            'team': 'alpha',<<NEWL>>            'cost_center': 'cc1234'<<NEWL>>        }<<NEWL>>    }<<NEWL>><<NEWL>>    # Call the API.<<NEWL>>    created_key = client.create_crypto_key(<<NEWL>>        request={'parent': key_ring_name, 'crypto_key_id': key_id, 'crypto_key': key})<<NEWL>>    print('Created labeled key: {}'.format(created_key.name))<<NEWL>>    return created_key<<NEWL>># [END kms_create_key_labels]"
31	adjudicated	1	"from pathlib import Path<<NEWL>><<NEWL>>from django.dispatch import receiver<<NEWL>>from django.template import engines<<NEWL>>from django.template.backends.django import DjangoTemplates<<NEWL>>from django.utils._os import to_path<<NEWL>>from django.utils.autoreload import autoreload_started, file_changed, is_django_path<<NEWL>><<NEWL>><<NEWL>>def get_template_directories():<<NEWL>>    # Iterate through each template backend and find<<NEWL>>    # any template_loader that has a 'get_dirs' method.<<NEWL>>    # Collect the directories, filtering out Django templates.<<NEWL>>    cwd = Path.cwd()<<NEWL>>    items = set()<<NEWL>>    for backend in engines.all():<<NEWL>>        if not isinstance(backend, DjangoTemplates):<<NEWL>>            continue<<NEWL>><<NEWL>>        items.update(cwd / to_path(dir) for dir in backend.engine.dirs if dir)<<NEWL>><<NEWL>>        for loader in backend.engine.template_loaders:<<NEWL>>            if not hasattr(loader, ""get_dirs""):<<NEWL>>                continue<<NEWL>>            items.update(<<NEWL>>                cwd / to_path(directory)<<NEWL>>                for directory in loader.get_dirs()<<NEWL>>                if directory and not is_django_path(directory)<<NEWL>>            )<<NEWL>>    return items<<NEWL>><<NEWL>><<NEWL>>def reset_loaders():<<NEWL>>    for backend in engines.all():<<NEWL>>        if not isinstance(backend, DjangoTemplates):<<NEWL>>            continue<<NEWL>>        for loader in backend.engine.template_loaders:<<NEWL>>            loader.reset()<<NEWL>><<NEWL>><<NEWL>>@receiver(autoreload_started, dispatch_uid=""template_loaders_watch_changes"")<<NEWL>>def watch_for_template_changes(sender, **kwargs):<<NEWL>>    for directory in get_template_directories():<<NEWL>>        sender.watch_dir(directory, ""**/*"")<<NEWL>><<NEWL>><<NEWL>>@receiver(file_changed, dispatch_uid=""template_loaders_file_changed"")<<NEWL>>def template_changed(sender, file_path, **kwargs):<<NEWL>>    if file_path.suffix == "".py"":<<NEWL>>        return<<NEWL>>    for template_dir in get_template_directories():<<NEWL>>        if template_dir in file_path.parents:<<NEWL>>            reset_loaders()<<NEWL>>            return True"
213	adjudicated	1	"import contextlib<<NEWL>><<NEWL>>import rope.base.oi.soi<<NEWL>>import rope.base.pyobjects<<NEWL>>from rope.base import pynames, utils<<NEWL>><<NEWL>><<NEWL>>class DefinedName(pynames.DefinedName):<<NEWL>>    pass<<NEWL>><<NEWL>><<NEWL>>class AssignedName(pynames.AssignedName):<<NEWL>>    def __init__(self, lineno=None, module=None, pyobject=None):<<NEWL>>        self.lineno = lineno<<NEWL>>        self.module = module<<NEWL>>        self.assignments = []<<NEWL>>        self.pyobject = _Inferred(<<NEWL>>            self._get_inferred, pynames._get_concluded_data(module)<<NEWL>>        )<<NEWL>>        self.pyobject.set(pyobject)<<NEWL>><<NEWL>>    @utils.prevent_recursion(lambda: None)<<NEWL>>    def _get_inferred(self):<<NEWL>>        if self.module is not None:<<NEWL>>            return rope.base.oi.soi.infer_assigned_object(self)<<NEWL>><<NEWL>>    def get_object(self):<<NEWL>>        return self.pyobject.get()<<NEWL>><<NEWL>>    def get_definition_location(self):<<NEWL>>        """"""Returns a (module, lineno) tuple""""""<<NEWL>>        if self.lineno is None and self.assignments:<<NEWL>>            with contextlib.suppress(AttributeError):<<NEWL>>                self.lineno = self.assignments[0].get_lineno()<<NEWL>>        return (self.module, self.lineno)<<NEWL>><<NEWL>>    def invalidate(self):<<NEWL>>        """"""Forget the `PyObject` this `PyName` holds""""""<<NEWL>>        self.pyobject.set(None)<<NEWL>><<NEWL>><<NEWL>>class UnboundName(pynames.UnboundName):<<NEWL>>    pass<<NEWL>><<NEWL>><<NEWL>>class ParameterName(pynames.ParameterName):<<NEWL>>    def __init__(self, pyfunction, index):<<NEWL>>        self.pyfunction = pyfunction<<NEWL>>        self.index = index<<NEWL>><<NEWL>>    def get_object(self):<<NEWL>>        result = self.pyfunction.get_parameter(self.index)<<NEWL>>        if result is None:<<NEWL>>            result = rope.base.pyobjects.get_unknown()<<NEWL>>        return result<<NEWL>><<NEWL>>    def get_objects(self):<<NEWL>>        """"""Returns the list of objects passed as this parameter""""""<<NEWL>>        return rope.base.oi.soi.get_passed_objects(self.pyfunction, self.index)<<NEWL>><<NEWL>>    def get_definition_location(self):<<NEWL>>        return (self.pyfunction.get_module(), self.pyfunction.get_ast().lineno)<<NEWL>><<NEWL>><<NEWL>>class AssignmentValue(pynames.AssignmentValue):<<NEWL>>    pass<<NEWL>><<NEWL>><<NEWL>>class EvaluatedName(pynames.EvaluatedName):<<NEWL>>    pass<<NEWL>><<NEWL>><<NEWL>>class ImportedModule(pynames.ImportedModule):<<NEWL>>    pass<<NEWL>><<NEWL>><<NEWL>>class ImportedName(pynames.ImportedName):<<NEWL>>    pass<<NEWL>><<NEWL>><<NEWL>>_Inferred = pynames._Inferred"
182	adjudicated	1	"# Licensed to the Apache Software Foundation (ASF) under one<<NEWL>># or more contributor license agreements.  See the NOTICE file<<NEWL>># distributed with this work for additional information<<NEWL>># regarding copyright ownership.  The ASF licenses this file<<NEWL>># to you under the Apache License, Version 2.0 (the<<NEWL>># ""License""); you may not use this file except in compliance<<NEWL>># with the License.  You may obtain a copy of the License at<<NEWL>>#<<NEWL>>#   http://www.apache.org/licenses/LICENSE-2.0<<NEWL>>#<<NEWL>># Unless required by applicable law or agreed to in writing,<<NEWL>># software distributed under the License is distributed on an<<NEWL>># ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<<NEWL>># KIND, either express or implied.  See the License for the<<NEWL>># specific language governing permissions and limitations<<NEWL>># under the License.<<NEWL>>""""""Kerberos command.""""""<<NEWL>>from __future__ import annotations<<NEWL>><<NEWL>>import daemon<<NEWL>>from daemon.pidfile import TimeoutPIDLockFile<<NEWL>><<NEWL>>from airflow import settings<<NEWL>>from airflow.security import kerberos as krb<<NEWL>>from airflow.utils import cli as cli_utils<<NEWL>>from airflow.utils.cli import setup_locations<<NEWL>><<NEWL>><<NEWL>>@cli_utils.action_cli<<NEWL>>def kerberos(args):<<NEWL>>    """"""Start a kerberos ticket renewer.""""""<<NEWL>>    print(settings.HEADER)<<NEWL>><<NEWL>>    if args.daemon:<<NEWL>>        pid, stdout, stderr, _ = setup_locations(<<NEWL>>            ""kerberos"", args.pid, args.stdout, args.stderr, args.log_file<<NEWL>>        )<<NEWL>>        with open(stdout, ""a"") as stdout_handle, open(stderr, ""a"") as stderr_handle:<<NEWL>>            stdout_handle.truncate(0)<<NEWL>>            stderr_handle.truncate(0)<<NEWL>><<NEWL>>            ctx = daemon.DaemonContext(<<NEWL>>                pidfile=TimeoutPIDLockFile(pid, -1),<<NEWL>>                stdout=stdout_handle,<<NEWL>>                stderr=stderr_handle,<<NEWL>>                umask=int(settings.DAEMON_UMASK, 8),<<NEWL>>            )<<NEWL>><<NEWL>>            with ctx:<<NEWL>>                krb.run(principal=args.principal, keytab=args.keytab)<<NEWL>>    else:<<NEWL>>        krb.run(principal=args.principal, keytab=args.keytab)"
353	adjudicated	0	"import json<<NEWL>>import os<<NEWL>>import time<<NEWL>>import random<<NEWL>>from linkedin_api import Linkedin<<NEWL>>from dotenv import load_dotenv<<NEWL>>import sys<<NEWL>><<NEWL>>class Scrape():<<NEWL>>    def __init__(self, api):<<NEWL>>        self.api = api<<NEWL>>        <<NEWL>>    def read_json(self, filename='jobs.json'):<<NEWL>>        with open(filename, 'r') as file:<<NEWL>>            return json.load(file)<<NEWL>><<NEWL>>    def write_json(self, newData):<<NEWL>>        with open('jobs.json', 'r+') as file:<<NEWL>>            data = self.read_json()<<NEWL>>            data['job-list'].append(newData)<<NEWL>>            json.dump(data, file)<<NEWL>><<NEWL>>    def searchJobs(self, apiChosen, numberOfSearches, keywordChosen, offsetNumber):<<NEWL>>        jobs = apiChosen.search_jobs(keywordChosen, remote = 1, limit = \<<NEWL>>                            numberOfSearches, offset = offsetNumber)<<NEWL>>        for job in jobs:<<NEWL>>            title = job['title']<<NEWL>>            jobID = job['dashEntityUrn'].split(':')[-1] <<NEWL>>            location = job['formattedLocation']<<NEWL>>            #jobDetails = api.get_job(jobID)<<NEWL>>            jobLink = f'https://www.linkedin.com/jobs/view/{jobID}/'<<NEWL>>            job = {<<NEWL>>                ""Job title"":title,<<NEWL>>                ""Job link"":jobLink,<<NEWL>>                ""Location"":location<<NEWL>>            }<<NEWL>>            print(f""{title} : {jobID} : {location}"")<<NEWL>>            self.write_json(job)<<NEWL>>        <<NEWL>><<NEWL>>    def findSWEJobs(self, apiChosen):<<NEWL>>        listOfJobs = [""Software Developer"",""Software Engineer"", ""Software Intern"",""SDET"",""Developer Intern"",""Software co-op"",""Junior Developer""] <<NEWL>>        for i in range(11,101):<<NEWL>>            <<NEWL>>            for element in listOfJobs:<<NEWL>>                self.searchJobs(apiChosen, 1, element, i)<<NEWL>>                time.sleep(1*random.randint(1,5)+2)<<NEWL>>    <<NEWL>>if(__name__ == ""__main__""):<<NEWL>>    load_dotenv()<<NEWL>>    Password = os.getenv('PASSWORD')<<NEWL>>    Email = os.getenv('EMAIL')<<NEWL>>    api = Linkedin(Email, Password)<<NEWL>>    data = {""job-list"": [{}]}<<NEWL>>    with open('jobs.json', 'w') as file:<<NEWL>>        json.dump(data, file)<<NEWL>><<NEWL>>    scraper = Scrape(api)<<NEWL>>    scraper.findSWEJobs(api)<<NEWL>>    <<NEWL>>    "
242	adjudicated	0	"import re<<NEWL>>from typing import Iterable, List, Tuple<<NEWL>><<NEWL>>from .cells import cell_len, chop_cells<<NEWL>>from ._loop import loop_last<<NEWL>><<NEWL>>re_word = re.compile(r""\s*\S+\s*"")<<NEWL>><<NEWL>><<NEWL>>def words(text: str) -> Iterable[Tuple[int, int, str]]:<<NEWL>>    position = 0<<NEWL>>    word_match = re_word.match(text, position)<<NEWL>>    while word_match is not None:<<NEWL>>        start, end = word_match.span()<<NEWL>>        word = word_match.group(0)<<NEWL>>        yield start, end, word<<NEWL>>        word_match = re_word.match(text, end)<<NEWL>><<NEWL>><<NEWL>>def divide_line(text: str, width: int, fold: bool = True) -> List[int]:<<NEWL>>    divides: List[int] = []<<NEWL>>    append = divides.append<<NEWL>>    line_position = 0<<NEWL>>    _cell_len = cell_len<<NEWL>>    for start, _end, word in words(text):<<NEWL>>        word_length = _cell_len(word.rstrip())<<NEWL>>        if line_position + word_length > width:<<NEWL>>            if word_length > width:<<NEWL>>                if fold:<<NEWL>>                    for last, line in loop_last(<<NEWL>>                        chop_cells(word, width, position=line_position)<<NEWL>>                    ):<<NEWL>>                        if last:<<NEWL>>                            line_position = _cell_len(line)<<NEWL>>                        else:<<NEWL>>                            start += len(line)<<NEWL>>                            append(start)<<NEWL>>                else:<<NEWL>>                    if start:<<NEWL>>                        append(start)<<NEWL>>                    line_position = _cell_len(word)<<NEWL>>            elif line_position and start:<<NEWL>>                append(start)<<NEWL>>                line_position = _cell_len(word)<<NEWL>>        else:<<NEWL>>            line_position += _cell_len(word)<<NEWL>>    return divides<<NEWL>><<NEWL>><<NEWL>>if __name__ == ""__main__"":  # pragma: no cover<<NEWL>>    from .console import Console<<NEWL>><<NEWL>>    console = Console(width=10)<<NEWL>>    console.print(""12345 abcdefghijklmnopqrstuvwyxzABCDEFGHIJKLMNOPQRSTUVWXYZ 12345"")<<NEWL>>    print(chop_cells(""abcdefghijklmnopqrstuvwxyz"", 10, position=2))"
302	adjudicated	2	"from rx.core import Observable<<NEWL>>from rx.internal import extensionmethod<<NEWL>>import math<<NEWL>><<NEWL>><<NEWL>>def determine_median(sorted_list):<<NEWL>>    if len(sorted_list) == 0:<<NEWL>>        raise Exception(""The input sequence was empty"")<<NEWL>><<NEWL>>    if len(sorted_list) % 2 == 1:<<NEWL>>        return sorted_list[int((len(sorted_list) + 1) / 2) - 1]<<NEWL>>    else:<<NEWL>>        median_1 = sorted_list[int((len(sorted_list) + 1) / 2) - 1]<<NEWL>>        median_2 = sorted_list[int((len(sorted_list) + 1) / 2)]<<NEWL>>        return float(median_1 + median_2) / 2.0<<NEWL>><<NEWL>><<NEWL>>@extensionmethod(Observable)<<NEWL>>def median(self):<<NEWL>>    """"""<<NEWL>>    Calculates the statistical median on numerical emissions. The sequence must be finite.<<NEWL>>    """"""<<NEWL>>    return self.to_sorted_list().map(lambda l: determine_median(l))<<NEWL>><<NEWL>><<NEWL>>@extensionmethod(Observable)<<NEWL>>def mode(self):<<NEWL>>    """"""<<NEWL>>    Returns the most frequently emitted value (or ""values"" if they have the same number of occurrences).<<NEWL>>    The sequence must be finite.<<NEWL>>    """"""<<NEWL>>    return self.group_by(lambda v: v) \<<NEWL>>        .flat_map(lambda grp: grp.count().map(lambda ct: (grp.key, ct))) \<<NEWL>>        .to_sorted_list(lambda t: t[1], reverse=True) \<<NEWL>>        .flat_map(lambda l: Observable.from_(l).take_while(lambda t: t[1] == l[0][1])) \<<NEWL>>        .map(lambda t: t[0])<<NEWL>><<NEWL>><<NEWL>>@extensionmethod(Observable)<<NEWL>>def variance(self):<<NEWL>>    """"""<<NEWL>>    Returns the statistical variance of the numerical emissions.<<NEWL>>    The sequence must be finite.<<NEWL>>    """"""<<NEWL>>    squared_values = self.to_list() \<<NEWL>>        .flat_map(lambda l: Observable.from_(l).average().flat_map(lambda avg: Observable.from_(l).map(lambda i: i - avg))) \<<NEWL>>        .map(lambda i: i * i) \<<NEWL>>        .publish() \<<NEWL>>        .auto_connect(2)<<NEWL>><<NEWL>>    return Observable.zip(squared_values.sum(), squared_values.count(), lambda sum, ct: sum / (ct - 1))<<NEWL>><<NEWL>><<NEWL>>@extensionmethod(Observable)<<NEWL>>def standard_deviation(self):<<NEWL>>    """"""<<NEWL>>    Returns the standard deviation of the numerical emissions:<<NEWL>>    The sequence must be finite.<<NEWL>>    """"""<<NEWL>>    return self.variance().map(lambda i: math.sqrt(i))<<NEWL>><<NEWL>>"
93	adjudicated	3	"import pytest<<NEWL>><<NEWL>>from pandas import TimedeltaIndex<<NEWL>><<NEWL>>from pandas.tseries.offsets import (<<NEWL>>    DateOffset,<<NEWL>>    Day,<<NEWL>>    Hour,<<NEWL>>)<<NEWL>><<NEWL>><<NEWL>>class TestFreq:<<NEWL>>    @pytest.mark.parametrize(""values"", [[""0 days"", ""2 days"", ""4 days""], []])<<NEWL>>    @pytest.mark.parametrize(""freq"", [""2D"", Day(2), ""48H"", Hour(48)])<<NEWL>>    def test_freq_setter(self, values, freq):<<NEWL>>        # GH#20678<<NEWL>>        idx = TimedeltaIndex(values)<<NEWL>><<NEWL>>        # can set to an offset, converting from string if necessary<<NEWL>>        idx._data.freq = freq<<NEWL>>        assert idx.freq == freq<<NEWL>>        assert isinstance(idx.freq, DateOffset)<<NEWL>><<NEWL>>        # can reset to None<<NEWL>>        idx._data.freq = None<<NEWL>>        assert idx.freq is None<<NEWL>><<NEWL>>    def test_freq_setter_errors(self):<<NEWL>>        # GH#20678<<NEWL>>        idx = TimedeltaIndex([""0 days"", ""2 days"", ""4 days""])<<NEWL>><<NEWL>>        # setting with an incompatible freq<<NEWL>>        msg = (<<NEWL>>            ""Inferred frequency 2D from passed values does not conform to ""<<NEWL>>            ""passed frequency 5D""<<NEWL>>        )<<NEWL>>        with pytest.raises(ValueError, match=msg):<<NEWL>>            idx._data.freq = ""5D""<<NEWL>><<NEWL>>        # setting with a non-fixed frequency<<NEWL>>        msg = r""<2 \* BusinessDays> is a non-fixed frequency""<<NEWL>>        with pytest.raises(ValueError, match=msg):<<NEWL>>            idx._data.freq = ""2B""<<NEWL>><<NEWL>>        # setting with non-freq string<<NEWL>>        with pytest.raises(ValueError, match=""Invalid frequency""):<<NEWL>>            idx._data.freq = ""foo""<<NEWL>><<NEWL>>    def test_freq_view_safe(self):<<NEWL>>        # Setting the freq for one TimedeltaIndex shouldn't alter the freq<<NEWL>>        #  for another that views the same data<<NEWL>><<NEWL>>        tdi = TimedeltaIndex([""0 days"", ""2 days"", ""4 days""], freq=""2D"")<<NEWL>>        tda = tdi._data<<NEWL>><<NEWL>>        tdi2 = TimedeltaIndex(tda)._with_freq(None)<<NEWL>>        assert tdi2.freq is None<<NEWL>><<NEWL>>        # Original was not altered<<NEWL>>        assert tdi.freq == ""2D""<<NEWL>>        assert tda.freq == ""2D"""
394	adjudicated	2	"import sys<<NEWL>>from dataclasses import dataclass<<NEWL>><<NEWL>><<NEWL>>@dataclass<<NEWL>>class WindowsConsoleFeatures:<<NEWL>>    """"""Windows features available.""""""<<NEWL>><<NEWL>>    vt: bool = False<<NEWL>>    """"""The console supports VT codes.""""""<<NEWL>>    truecolor: bool = False<<NEWL>>    """"""The console supports truecolor.""""""<<NEWL>><<NEWL>><<NEWL>>try:<<NEWL>>    import ctypes<<NEWL>>    from ctypes import LibraryLoader<<NEWL>><<NEWL>>    if sys.platform == ""win32"":<<NEWL>>        windll = LibraryLoader(ctypes.WinDLL)<<NEWL>>    else:<<NEWL>>        windll = None<<NEWL>>        raise ImportError(""Not windows"")<<NEWL>><<NEWL>>    from pip._vendor.rich._win32_console import (<<NEWL>>        ENABLE_VIRTUAL_TERMINAL_PROCESSING,<<NEWL>>        GetConsoleMode,<<NEWL>>        GetStdHandle,<<NEWL>>        LegacyWindowsError,<<NEWL>>    )<<NEWL>><<NEWL>>except (AttributeError, ImportError, ValueError):<<NEWL>><<NEWL>>    # Fallback if we can't load the Windows DLL<<NEWL>>    def get_windows_console_features() -> WindowsConsoleFeatures:<<NEWL>>        features = WindowsConsoleFeatures()<<NEWL>>        return features<<NEWL>><<NEWL>>else:<<NEWL>><<NEWL>>    def get_windows_console_features() -> WindowsConsoleFeatures:<<NEWL>>        """"""Get windows console features.<<NEWL>><<NEWL>>        Returns:<<NEWL>>            WindowsConsoleFeatures: An instance of WindowsConsoleFeatures.<<NEWL>>        """"""<<NEWL>>        handle = GetStdHandle()<<NEWL>>        try:<<NEWL>>            console_mode = GetConsoleMode(handle)<<NEWL>>            success = True<<NEWL>>        except LegacyWindowsError:<<NEWL>>            console_mode = 0<<NEWL>>            success = False<<NEWL>>        vt = bool(success and console_mode & ENABLE_VIRTUAL_TERMINAL_PROCESSING)<<NEWL>>        truecolor = False<<NEWL>>        if vt:<<NEWL>>            win_version = sys.getwindowsversion()<<NEWL>>            truecolor = win_version.major > 10 or (<<NEWL>>                win_version.major == 10 and win_version.build >= 15063<<NEWL>>            )<<NEWL>>        features = WindowsConsoleFeatures(vt=vt, truecolor=truecolor)<<NEWL>>        return features<<NEWL>><<NEWL>><<NEWL>>if __name__ == ""__main__"":<<NEWL>>    import platform<<NEWL>><<NEWL>>    features = get_windows_console_features()<<NEWL>>    from pip._vendor.rich import print<<NEWL>><<NEWL>>    print(f'platform=""{platform.system()}""')<<NEWL>>    print(repr(features))"
5	adjudicated	1	"# coding: utf8<<NEWL>>from __future__ import unicode_literals<<NEWL>><<NEWL>>from ...symbols import ORTH, LEMMA, NORM<<NEWL>><<NEWL>>_exc = {}<<NEWL>><<NEWL>>_abbrev_exc = [<<NEWL>>    # Weekdays abbreviations<<NEWL>>    {ORTH: """", LEMMA: """"},<<NEWL>>    {ORTH: """", LEMMA: """"},<<NEWL>>    {ORTH: """", LEMMA: """"},<<NEWL>>    {ORTH: """", LEMMA: """"},<<NEWL>>    {ORTH: """", LEMMA: """"},<<NEWL>>    {ORTH: """", LEMMA: """"},<<NEWL>>    {ORTH: """", LEMMA: """"},<<NEWL>>    # Months abbreviations<<NEWL>>    {ORTH: """", LEMMA: """"},<<NEWL>>    {ORTH: """", LEMMA: """"},<<NEWL>>    {ORTH: """", LEMMA: """"},<<NEWL>>    {ORTH: """", LEMMA: """"},<<NEWL>>    {ORTH: """", LEMMA: """"},<<NEWL>>    {ORTH: """", LEMMA: """"},<<NEWL>>    {ORTH: """", LEMMA: """"},<<NEWL>>    {ORTH: """", LEMMA: """"},<<NEWL>>    {ORTH: """", LEMMA: """"},<<NEWL>>    {ORTH: """", LEMMA: """"},<<NEWL>>    {ORTH: """", LEMMA: """"},<<NEWL>>    {ORTH: """", LEMMA: """"},<<NEWL>>    # Number abbreviations<<NEWL>>    {ORTH: """", LEMMA: """"},<<NEWL>>    {ORTH: """", LEMMA: """"},<<NEWL>>]<<NEWL>><<NEWL>>for abbr in _abbrev_exc:<<NEWL>>    for orth in (abbr[ORTH], abbr[ORTH].capitalize(), abbr[ORTH].upper()):<<NEWL>>        _exc[orth] = [{ORTH: orth, LEMMA: abbr[LEMMA], NORM: abbr[LEMMA]}]<<NEWL>>        _exc[orth + "".""] = [{ORTH: orth + ""."", LEMMA: abbr[LEMMA], NORM: abbr[LEMMA]}]<<NEWL>><<NEWL>>for exc_data in [  # ""etc."" abbreviations<<NEWL>>    {ORTH: ""..."", NORM: ""  ""},<<NEWL>>    {ORTH: "".."", NORM: "" ""},<<NEWL>>    {ORTH: ""..."", NORM: ""  ""},<<NEWL>>    {ORTH: "".."", NORM: "" ""},<<NEWL>>]:<<NEWL>>    exc_data[LEMMA] = exc_data[NORM]<<NEWL>>    _exc[exc_data[ORTH]] = [exc_data]<<NEWL>><<NEWL>>TOKENIZER_EXCEPTIONS = _exc"
145	adjudicated	2	"from selenium.webdriver.common.keys import Keys<<NEWL>>from .utils import shift<<NEWL>><<NEWL>>INITIAL_CELLS = ['print(""a"")', 'print(""b"")', 'print(""c"")']<<NEWL>><<NEWL>>def test_insert_cell(prefill_notebook):<<NEWL>>    notebook = prefill_notebook(INITIAL_CELLS)<<NEWL>><<NEWL>>    notebook.to_command_mode()<<NEWL>>    notebook.focus_cell(2)<<NEWL>>    notebook.convert_cell_type(2, ""markdown"")<<NEWL>>    <<NEWL>>    # insert code cell above<<NEWL>>    notebook.current_cell.send_keys(""a"")<<NEWL>>    assert notebook.get_cell_contents(2) == """"<<NEWL>>    assert notebook.get_cell_type(2) == ""code""<<NEWL>>    assert len(notebook.cells) == 4<<NEWL>>    <<NEWL>>    # insert code cell below<<NEWL>>    notebook.current_cell.send_keys(""b"")<<NEWL>>    assert notebook.get_cell_contents(2) == """"<<NEWL>>    assert notebook.get_cell_contents(3) == """"<<NEWL>>    assert notebook.get_cell_type(3) == ""code""<<NEWL>>    assert len(notebook.cells) == 5<<NEWL>><<NEWL>>    notebook.edit_cell(index=1, content=""cell1"")<<NEWL>>    notebook.focus_cell(1)<<NEWL>>    notebook.current_cell.send_keys(""a"")<<NEWL>>    assert notebook.get_cell_contents(1) == """"<<NEWL>>    assert notebook.get_cell_contents(2) == ""cell1""<<NEWL>><<NEWL>>    notebook.edit_cell(index=1, content='cell1')<<NEWL>>    notebook.edit_cell(index=2, content='cell2')<<NEWL>>    notebook.edit_cell(index=3, content='cell3')<<NEWL>>    notebook.focus_cell(2)<<NEWL>>    notebook.current_cell.send_keys(""b"")<<NEWL>>    assert notebook.get_cell_contents(1) == ""cell1""<<NEWL>>    assert notebook.get_cell_contents(2) == ""cell2""<<NEWL>>    assert notebook.get_cell_contents(3) == """"<<NEWL>>    assert notebook.get_cell_contents(4) == ""cell3""<<NEWL>><<NEWL>>    # insert above multiple selected cells<<NEWL>>    notebook.focus_cell(1)<<NEWL>>    shift(notebook.browser, Keys.DOWN)<<NEWL>>    notebook.current_cell.send_keys('a')<<NEWL>>    <<NEWL>>    # insert below multiple selected cells<<NEWL>>    notebook.focus_cell(2)<<NEWL>>    shift(notebook.browser, Keys.DOWN)<<NEWL>>    notebook.current_cell.send_keys('b')<<NEWL>>    assert notebook.get_cells_contents()[1:5] == ["""", ""cell1"", ""cell2"", """"]"
54	adjudicated	1	"import numpy as np<<NEWL>>import pytest<<NEWL>><<NEWL>>import pandas.util._test_decorators as td<<NEWL>><<NEWL>>from pandas import DataFrame<<NEWL>>import pandas._testing as tm<<NEWL>><<NEWL>><<NEWL>>class TestCopy:<<NEWL>>    @pytest.mark.parametrize(""attr"", [""index"", ""columns""])<<NEWL>>    def test_copy_index_name_checking(self, float_frame, attr):<<NEWL>>        # don't want to be able to modify the index stored elsewhere after<<NEWL>>        # making a copy<<NEWL>>        ind = getattr(float_frame, attr)<<NEWL>>        ind.name = None<<NEWL>>        cp = float_frame.copy()<<NEWL>>        getattr(cp, attr).name = ""foo""<<NEWL>>        assert getattr(float_frame, attr).name is None<<NEWL>><<NEWL>>    def test_copy_cache(self):<<NEWL>>        # GH#31784 _item_cache not cleared on copy causes incorrect reads after updates<<NEWL>>        df = DataFrame({""a"": [1]})<<NEWL>><<NEWL>>        df[""x""] = [0]<<NEWL>>        df[""a""]<<NEWL>><<NEWL>>        df.copy()<<NEWL>><<NEWL>>        df[""a""].values[0] = -1<<NEWL>><<NEWL>>        tm.assert_frame_equal(df, DataFrame({""a"": [-1], ""x"": [0]}))<<NEWL>><<NEWL>>        df[""y""] = [0]<<NEWL>><<NEWL>>        assert df[""a""].values[0] == -1<<NEWL>>        tm.assert_frame_equal(df, DataFrame({""a"": [-1], ""x"": [0], ""y"": [0]}))<<NEWL>><<NEWL>>    def test_copy(self, float_frame, float_string_frame):<<NEWL>>        cop = float_frame.copy()<<NEWL>>        cop[""E""] = cop[""A""]<<NEWL>>        assert ""E"" not in float_frame<<NEWL>><<NEWL>>        # copy objects<<NEWL>>        copy = float_string_frame.copy()<<NEWL>>        assert copy._mgr is not float_string_frame._mgr<<NEWL>><<NEWL>>    @td.skip_array_manager_invalid_test<<NEWL>>    def test_copy_consolidates(self):<<NEWL>>        # GH#42477<<NEWL>>        df = DataFrame(<<NEWL>>            {<<NEWL>>                ""a"": np.random.randint(0, 100, size=55),<<NEWL>>                ""b"": np.random.randint(0, 100, size=55),<<NEWL>>            }<<NEWL>>        )<<NEWL>><<NEWL>>        for i in range(0, 10):<<NEWL>>            df.loc[:, f""n_{i}""] = np.random.randint(0, 100, size=55)<<NEWL>><<NEWL>>        assert len(df._mgr.blocks) == 11<<NEWL>>        result = df.copy()<<NEWL>>        assert len(result._mgr.blocks) == 1"
285	adjudicated	1	"import sys<<NEWL>><<NEWL>><<NEWL>>def patch_sys_module():<<NEWL>><<NEWL>>    def patched_exc_info(fun):<<NEWL>><<NEWL>>        def pydev_debugger_exc_info():<<NEWL>>            type, value, traceback = fun()<<NEWL>>            if type == ImportError:<<NEWL>>                # we should not show frame added by plugin_import call<<NEWL>>                if traceback and hasattr(traceback, ""tb_next""):<<NEWL>>                    return type, value, traceback.tb_next<<NEWL>>            return type, value, traceback<<NEWL>><<NEWL>>        return pydev_debugger_exc_info<<NEWL>><<NEWL>>    system_exc_info = sys.exc_info<<NEWL>>    sys.exc_info = patched_exc_info(system_exc_info)<<NEWL>>    if not hasattr(sys, ""system_exc_info""):<<NEWL>>        sys.system_exc_info = system_exc_info<<NEWL>><<NEWL>><<NEWL>>def patched_reload(orig_reload):<<NEWL>><<NEWL>>    def pydev_debugger_reload(module):<<NEWL>>        orig_reload(module)<<NEWL>>        if module.__name__ == ""sys"":<<NEWL>>            # if sys module was reloaded we should patch it again<<NEWL>>            patch_sys_module()<<NEWL>><<NEWL>>    return pydev_debugger_reload<<NEWL>><<NEWL>><<NEWL>>def patch_reload():<<NEWL>>    import builtins  # Py3<<NEWL>><<NEWL>>    if hasattr(builtins, ""reload""):<<NEWL>>        sys.builtin_orig_reload = builtins.reload<<NEWL>>        builtins.reload = patched_reload(sys.builtin_orig_reload)  # @UndefinedVariable<<NEWL>>        try:<<NEWL>>            import imp<<NEWL>>            sys.imp_orig_reload = imp.reload<<NEWL>>            imp.reload = patched_reload(sys.imp_orig_reload)  # @UndefinedVariable<<NEWL>>        except:<<NEWL>>            pass<<NEWL>>    else:<<NEWL>>        try:<<NEWL>>            import importlib<<NEWL>>            sys.importlib_orig_reload = importlib.reload  # @UndefinedVariable<<NEWL>>            importlib.reload = patched_reload(sys.importlib_orig_reload)  # @UndefinedVariable<<NEWL>>        except:<<NEWL>>            pass<<NEWL>><<NEWL>>    del builtins<<NEWL>><<NEWL>><<NEWL>>def cancel_patches_in_sys_module():<<NEWL>>    sys.exc_info = sys.system_exc_info  # @UndefinedVariable<<NEWL>>    import builtins  # Py3<<NEWL>><<NEWL>>    if hasattr(sys, ""builtin_orig_reload""):<<NEWL>>        builtins.reload = sys.builtin_orig_reload<<NEWL>><<NEWL>>    if hasattr(sys, ""imp_orig_reload""):<<NEWL>>        import imp<<NEWL>>        imp.reload = sys.imp_orig_reload<<NEWL>><<NEWL>>    if hasattr(sys, ""importlib_orig_reload""):<<NEWL>>        import importlib<<NEWL>>        importlib.reload = sys.importlib_orig_reload<<NEWL>><<NEWL>>    del builtins"
114	adjudicated	2	"import _plotly_utils.basevalidators<<NEWL>><<NEWL>><<NEWL>>class FontValidator(_plotly_utils.basevalidators.CompoundValidator):<<NEWL>>    def __init__(self, plotly_name=""font"", parent_name=""ohlc.hoverlabel"", **kwargs):<<NEWL>>        super(FontValidator, self).__init__(<<NEWL>>            plotly_name=plotly_name,<<NEWL>>            parent_name=parent_name,<<NEWL>>            data_class_str=kwargs.pop(""data_class_str"", ""Font""),<<NEWL>>            data_docs=kwargs.pop(<<NEWL>>                ""data_docs"",<<NEWL>>                """"""<<NEWL>>            color<<NEWL>><<NEWL>>            colorsrc<<NEWL>>                Sets the source reference on Chart Studio Cloud<<NEWL>>                for `color`.<<NEWL>>            family<<NEWL>>                HTML font family - the typeface that will be<<NEWL>>                applied by the web browser. The web browser<<NEWL>>                will only be able to apply a font if it is<<NEWL>>                available on the system which it operates.<<NEWL>>                Provide multiple font families, separated by<<NEWL>>                commas, to indicate the preference in which to<<NEWL>>                apply fonts if they aren't available on the<<NEWL>>                system. The Chart Studio Cloud (at<<NEWL>>                https://chart-studio.plotly.com or on-premise)<<NEWL>>                generates images on a server, where only a<<NEWL>>                select number of fonts are installed and<<NEWL>>                supported. These include ""Arial"", ""Balto"",<<NEWL>>                ""Courier New"", ""Droid Sans"",, ""Droid Serif"",<<NEWL>>                ""Droid Sans Mono"", ""Gravitas One"", ""Old<<NEWL>>                Standard TT"", ""Open Sans"", ""Overpass"", ""PT Sans<<NEWL>>                Narrow"", ""Raleway"", ""Times New Roman"".<<NEWL>>            familysrc<<NEWL>>                Sets the source reference on Chart Studio Cloud<<NEWL>>                for `family`.<<NEWL>>            size<<NEWL>><<NEWL>>            sizesrc<<NEWL>>                Sets the source reference on Chart Studio Cloud<<NEWL>>                for `size`.<<NEWL>>"""""",<<NEWL>>            ),<<NEWL>>            **kwargs,<<NEWL>>        )"
336	adjudicated	2	"from fontTools.pens.basePen import BasePen<<NEWL>>from reportlab.graphics.shapes import Path<<NEWL>><<NEWL>><<NEWL>>__all__ = [""ReportLabPen""]<<NEWL>><<NEWL>><<NEWL>>class ReportLabPen(BasePen):<<NEWL>><<NEWL>>    """"""A pen for drawing onto a ``reportlab.graphics.shapes.Path`` object.""""""<<NEWL>><<NEWL>>    def __init__(self, glyphSet, path=None):<<NEWL>>        BasePen.__init__(self, glyphSet)<<NEWL>>        if path is None:<<NEWL>>            path = Path()<<NEWL>>        self.path = path<<NEWL>><<NEWL>>    def _moveTo(self, p):<<NEWL>>        (x, y) = p<<NEWL>>        self.path.moveTo(x, y)<<NEWL>><<NEWL>>    def _lineTo(self, p):<<NEWL>>        (x, y) = p<<NEWL>>        self.path.lineTo(x, y)<<NEWL>><<NEWL>>    def _curveToOne(self, p1, p2, p3):<<NEWL>>        (x1, y1) = p1<<NEWL>>        (x2, y2) = p2<<NEWL>>        (x3, y3) = p3<<NEWL>>        self.path.curveTo(x1, y1, x2, y2, x3, y3)<<NEWL>><<NEWL>>    def _closePath(self):<<NEWL>>        self.path.closePath()<<NEWL>><<NEWL>><<NEWL>>if __name__ == ""__main__"":<<NEWL>>    import sys<<NEWL>><<NEWL>>    if len(sys.argv) < 3:<<NEWL>>        print(<<NEWL>>            ""Usage: reportLabPen.py <OTF/TTF font> <glyphname> [<image file to create>]""<<NEWL>>        )<<NEWL>>        print(<<NEWL>>            ""  If no image file name is created, by default <glyphname>.png is created.""<<NEWL>>        )<<NEWL>>        print(""  example: reportLabPen.py Arial.TTF R test.png"")<<NEWL>>        print(<<NEWL>>            ""  (The file format will be PNG, regardless of the image file name supplied)""<<NEWL>>        )<<NEWL>>        sys.exit(0)<<NEWL>><<NEWL>>    from fontTools.ttLib import TTFont<<NEWL>>    from reportlab.lib import colors<<NEWL>><<NEWL>>    path = sys.argv[1]<<NEWL>>    glyphName = sys.argv[2]<<NEWL>>    if len(sys.argv) > 3:<<NEWL>>        imageFile = sys.argv[3]<<NEWL>>    else:<<NEWL>>        imageFile = ""%s.png"" % glyphName<<NEWL>><<NEWL>>    font = TTFont(path)  # it would work just as well with fontTools.t1Lib.T1Font<<NEWL>>    gs = font.getGlyphSet()<<NEWL>>    pen = ReportLabPen(gs, Path(fillColor=colors.red, strokeWidth=5))<<NEWL>>    g = gs[glyphName]<<NEWL>>    g.draw(pen)<<NEWL>><<NEWL>>    w, h = g.width, 1000<<NEWL>>    from reportlab.graphics import renderPM<<NEWL>>    from reportlab.graphics.shapes import Group, Drawing, scale<<NEWL>><<NEWL>>    # Everything is wrapped in a group to allow transformations.<<NEWL>>    g = Group(pen.path)<<NEWL>>    g.translate(0, 200)<<NEWL>>    g.scale(0.3, 0.3)<<NEWL>><<NEWL>>    d = Drawing(w, h)<<NEWL>>    d.add(g)<<NEWL>><<NEWL>>    renderPM.drawToFile(d, imageFile, fmt=""PNG"")"
276	adjudicated	4	"# Kills a process by process name<<NEWL>>#<<NEWL>># Uses the Performance Data Helper to locate the PID, then kills it.<<NEWL>># Will only kill the process if there is only one process of that name<<NEWL>># (eg, attempting to kill ""Python.exe"" will only work if there is only<<NEWL>># one Python.exe running.  (Note that the current process does not<<NEWL>># count - ie, if Python.exe is hosting this script, you can still kill<<NEWL>># another Python.exe (as long as there is only one other Python.exe)<<NEWL>><<NEWL>># Really just a demo for the win32pdh(util) module, which allows you<<NEWL>># to get all sorts of information about a running process and many<<NEWL>># other aspects of your system.<<NEWL>><<NEWL>>import win32api, win32pdhutil, win32con, sys<<NEWL>><<NEWL>><<NEWL>>def killProcName(procname):<<NEWL>>    # Change suggested by Dan Knierim, who found that this performed a<<NEWL>>    # ""refresh"", allowing us to kill processes created since this was run<<NEWL>>    # for the first time.<<NEWL>>    try:<<NEWL>>        win32pdhutil.GetPerformanceAttributes(""Process"", ""ID Process"", procname)<<NEWL>>    except:<<NEWL>>        pass<<NEWL>><<NEWL>>    pids = win32pdhutil.FindPerformanceAttributesByName(procname)<<NEWL>><<NEWL>>    # If _my_ pid in there, remove it!<<NEWL>>    try:<<NEWL>>        pids.remove(win32api.GetCurrentProcessId())<<NEWL>>    except ValueError:<<NEWL>>        pass<<NEWL>><<NEWL>>    if len(pids) == 0:<<NEWL>>        result = ""Can't find %s"" % procname<<NEWL>>    elif len(pids) > 1:<<NEWL>>        result = ""Found too many %s's - pids=`%s`"" % (procname, pids)<<NEWL>>    else:<<NEWL>>        handle = win32api.OpenProcess(win32con.PROCESS_TERMINATE, 0, pids[0])<<NEWL>>        win32api.TerminateProcess(handle, 0)<<NEWL>>        win32api.CloseHandle(handle)<<NEWL>>        result = """"<<NEWL>><<NEWL>>    return result<<NEWL>><<NEWL>><<NEWL>>if __name__ == ""__main__"":<<NEWL>>    if len(sys.argv) > 1:<<NEWL>>        for procname in sys.argv[1:]:<<NEWL>>            result = killProcName(procname)<<NEWL>>            if result:<<NEWL>>                print(result)<<NEWL>>                print(""Dumping all processes..."")<<NEWL>>                win32pdhutil.ShowAllProcesses()<<NEWL>>            else:<<NEWL>>                print(""Killed %s"" % procname)<<NEWL>>    else:<<NEWL>>        print(""Usage: killProcName.py procname ..."")"
227	adjudicated	3	"# Copyright 2019 Google, LLC.<<NEWL>>#<<NEWL>># Licensed under the Apache License, Version 2.0 (the ""License"");<<NEWL>># you may not use this file except in compliance with the License.<<NEWL>># You may obtain a copy of the License at<<NEWL>>#<<NEWL>>#    http://www.apache.org/licenses/LICENSE-2.0<<NEWL>>#<<NEWL>># Unless required by applicable law or agreed to in writing, software<<NEWL>># distributed under the License is distributed on an ""AS IS"" BASIS,<<NEWL>># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<<NEWL>># See the License for the specific language governing permissions and<<NEWL>># limitations under the License.<<NEWL>><<NEWL>># [START cloudrun_broken_service]<<NEWL>># [START run_broken_service]<<NEWL>>import json<<NEWL>>import os<<NEWL>><<NEWL>>from flask import Flask<<NEWL>><<NEWL>><<NEWL>>app = Flask(__name__)<<NEWL>><<NEWL>><<NEWL>>@app.route(""/"", methods=[""GET""])<<NEWL>>def index():<<NEWL>>    print(""hello: received request."")<<NEWL>><<NEWL>>    # [START cloudrun_broken_service_problem]<<NEWL>>    # [START run_broken_service_problem]<<NEWL>>    NAME = os.getenv(""NAME"")<<NEWL>><<NEWL>>    if not NAME:<<NEWL>>        print(""Environment validation failed."")<<NEWL>>        raise Exception(""Missing required service parameter."")<<NEWL>>    # [END run_broken_service_problem]<<NEWL>>    # [END cloudrun_broken_service_problem]<<NEWL>><<NEWL>>    return f""Hello {NAME}""<<NEWL>><<NEWL>><<NEWL>># [END run_broken_service]<<NEWL>># [END cloudrun_broken_service]<<NEWL>><<NEWL>><<NEWL>>@app.route(""/improved"", methods=[""GET""])<<NEWL>>def improved():<<NEWL>>    print(""hello: received request."")<<NEWL>><<NEWL>>    # [START cloudrun_broken_service_upgrade]<<NEWL>>    # [START run_broken_service_upgrade]<<NEWL>>    NAME = os.getenv(""NAME"")<<NEWL>><<NEWL>>    if not NAME:<<NEWL>>        NAME = ""World""<<NEWL>>        error_message = {<<NEWL>>            ""severity"": ""WARNING"",<<NEWL>>            ""message"": f""NAME not set, default to {NAME}"",<<NEWL>>        }<<NEWL>>        print(json.dumps(error_message))<<NEWL>>    # [END run_broken_service_upgrade]<<NEWL>>    # [END cloudrun_broken_service_upgrade]<<NEWL>><<NEWL>>    return f""Hello {NAME}""<<NEWL>><<NEWL>><<NEWL>># [START cloudrun_broken_service]<<NEWL>># [START run_broken_service]<<NEWL>>if __name__ == ""__main__"":<<NEWL>>    PORT = int(os.getenv(""PORT"")) if os.getenv(""PORT"") else 8080<<NEWL>><<NEWL>>    # This is used when running locally. Gunicorn is used to run the<<NEWL>>    # application on Cloud Run. See entrypoint in Dockerfile.<<NEWL>>    app.run(host=""127.0.0.1"", port=PORT, debug=True)<<NEWL>># [END run_broken_service]<<NEWL>># [END cloudrun_broken_service]"
429	adjudicated	1	"from django.apps import apps<<NEWL>>from django.conf import settings<<NEWL>>from django.contrib.redirects.models import Redirect<<NEWL>>from django.contrib.sites.shortcuts import get_current_site<<NEWL>>from django.core.exceptions import ImproperlyConfigured<<NEWL>>from django.http import HttpResponseGone, HttpResponsePermanentRedirect<<NEWL>>from django.utils.deprecation import MiddlewareMixin<<NEWL>><<NEWL>><<NEWL>>class RedirectFallbackMiddleware(MiddlewareMixin):<<NEWL>>    # Defined as class-level attributes to be subclassing-friendly.<<NEWL>>    response_gone_class = HttpResponseGone<<NEWL>>    response_redirect_class = HttpResponsePermanentRedirect<<NEWL>><<NEWL>>    def __init__(self, get_response):<<NEWL>>        if not apps.is_installed(""django.contrib.sites""):<<NEWL>>            raise ImproperlyConfigured(<<NEWL>>                ""You cannot use RedirectFallbackMiddleware when ""<<NEWL>>                ""django.contrib.sites is not installed.""<<NEWL>>            )<<NEWL>>        super().__init__(get_response)<<NEWL>><<NEWL>>    def process_response(self, request, response):<<NEWL>>        # No need to check for a redirect for non-404 responses.<<NEWL>>        if response.status_code != 404:<<NEWL>>            return response<<NEWL>><<NEWL>>        full_path = request.get_full_path()<<NEWL>>        current_site = get_current_site(request)<<NEWL>><<NEWL>>        r = None<<NEWL>>        try:<<NEWL>>            r = Redirect.objects.get(site=current_site, old_path=full_path)<<NEWL>>        except Redirect.DoesNotExist:<<NEWL>>            pass<<NEWL>>        if r is None and settings.APPEND_SLASH and not request.path.endswith(""/""):<<NEWL>>            try:<<NEWL>>                r = Redirect.objects.get(<<NEWL>>                    site=current_site,<<NEWL>>                    old_path=request.get_full_path(force_append_slash=True),<<NEWL>>                )<<NEWL>>            except Redirect.DoesNotExist:<<NEWL>>                pass<<NEWL>>        if r is not None:<<NEWL>>            if r.new_path == """":<<NEWL>>                return self.response_gone_class()<<NEWL>>            return self.response_redirect_class(r.new_path)<<NEWL>><<NEWL>>        # No redirect was found. Return the response.<<NEWL>>        return response"
478	adjudicated	2	"import numpy as np<<NEWL>>import pytest<<NEWL>><<NEWL>>import pandas as pd<<NEWL>>import pandas._testing as tm<<NEWL>>from pandas.arrays import BooleanArray<<NEWL>>from pandas.tests.arrays.masked_shared import ComparisonOps<<NEWL>><<NEWL>><<NEWL>>@pytest.fixture<<NEWL>>def data():<<NEWL>>    """"""Fixture returning boolean array with valid and missing data""""""<<NEWL>>    return pd.array(<<NEWL>>        [True, False] * 4 + [np.nan] + [True, False] * 44 + [np.nan] + [True, False],<<NEWL>>        dtype=""boolean"",<<NEWL>>    )<<NEWL>><<NEWL>><<NEWL>>@pytest.fixture<<NEWL>>def dtype():<<NEWL>>    """"""Fixture returning BooleanDtype""""""<<NEWL>>    return pd.BooleanDtype()<<NEWL>><<NEWL>><<NEWL>>class TestComparisonOps(ComparisonOps):<<NEWL>>    def test_compare_scalar(self, data, comparison_op):<<NEWL>>        self._compare_other(data, comparison_op, True)<<NEWL>><<NEWL>>    def test_compare_array(self, data, comparison_op):<<NEWL>>        other = pd.array([True] * len(data), dtype=""boolean"")<<NEWL>>        self._compare_other(data, comparison_op, other)<<NEWL>>        other = np.array([True] * len(data))<<NEWL>>        self._compare_other(data, comparison_op, other)<<NEWL>>        other = pd.Series([True] * len(data))<<NEWL>>        self._compare_other(data, comparison_op, other)<<NEWL>><<NEWL>>    @pytest.mark.parametrize(""other"", [True, False, pd.NA])<<NEWL>>    def test_scalar(self, other, comparison_op, dtype):<<NEWL>>        ComparisonOps.test_scalar(self, other, comparison_op, dtype)<<NEWL>><<NEWL>>    def test_array(self, comparison_op):<<NEWL>>        op = comparison_op<<NEWL>>        a = pd.array([True] * 3 + [False] * 3 + [None] * 3, dtype=""boolean"")<<NEWL>>        b = pd.array([True, False, None] * 3, dtype=""boolean"")<<NEWL>><<NEWL>>        result = op(a, b)<<NEWL>><<NEWL>>        values = op(a._data, b._data)<<NEWL>>        mask = a._mask | b._mask<<NEWL>>        expected = BooleanArray(values, mask)<<NEWL>>        tm.assert_extension_array_equal(result, expected)<<NEWL>><<NEWL>>        # ensure we haven't mutated anything inplace<<NEWL>>        result[0] = None<<NEWL>>        tm.assert_extension_array_equal(<<NEWL>>            a, pd.array([True] * 3 + [False] * 3 + [None] * 3, dtype=""boolean"")<<NEWL>>        )<<NEWL>>        tm.assert_extension_array_equal(<<NEWL>>            b, pd.array([True, False, None] * 3, dtype=""boolean"")<<NEWL>>        )"
468	adjudicated	2	"import _plotly_utils.basevalidators<<NEWL>><<NEWL>><<NEWL>>class HoverlabelValidator(_plotly_utils.basevalidators.CompoundValidator):<<NEWL>>    def __init__(self, plotly_name=""hoverlabel"", parent_name=""scatter3d"", **kwargs):<<NEWL>>        super(HoverlabelValidator, self).__init__(<<NEWL>>            plotly_name=plotly_name,<<NEWL>>            parent_name=parent_name,<<NEWL>>            data_class_str=kwargs.pop(""data_class_str"", ""Hoverlabel""),<<NEWL>>            data_docs=kwargs.pop(<<NEWL>>                ""data_docs"",<<NEWL>>                """"""<<NEWL>>            align<<NEWL>>                Sets the horizontal alignment of the text<<NEWL>>                content within hover label box. Has an effect<<NEWL>>                only if the hover label text spans more two or<<NEWL>>                more lines<<NEWL>>            alignsrc<<NEWL>>                Sets the source reference on Chart Studio Cloud<<NEWL>>                for `align`.<<NEWL>>            bgcolor<<NEWL>>                Sets the background color of the hover labels<<NEWL>>                for this trace<<NEWL>>            bgcolorsrc<<NEWL>>                Sets the source reference on Chart Studio Cloud<<NEWL>>                for `bgcolor`.<<NEWL>>            bordercolor<<NEWL>>                Sets the border color of the hover labels for<<NEWL>>                this trace.<<NEWL>>            bordercolorsrc<<NEWL>>                Sets the source reference on Chart Studio Cloud<<NEWL>>                for `bordercolor`.<<NEWL>>            font<<NEWL>>                Sets the font used in hover labels.<<NEWL>>            namelength<<NEWL>>                Sets the default length (in number of<<NEWL>>                characters) of the trace name in the hover<<NEWL>>                labels for all traces. -1 shows the whole name<<NEWL>>                regardless of length. 0-3 shows the first 0-3<<NEWL>>                characters, and an integer >3 will show the<<NEWL>>                whole name if it is less than that many<<NEWL>>                characters, but if it is longer, will truncate<<NEWL>>                to `namelength - 3` characters and add an<<NEWL>>                ellipsis.<<NEWL>>            namelengthsrc<<NEWL>>                Sets the source reference on Chart Studio Cloud<<NEWL>>                for `namelength`.<<NEWL>>"""""",<<NEWL>>            ),<<NEWL>>            **kwargs,<<NEWL>>        )"
439	adjudicated	3	from __future__ import unicode_literals<<NEWL>><<NEWL>># For backwards-compatibility. keep this file.<<NEWL>># (Many people are going to have key bindings that rely on this file.)<<NEWL>>from .app import *<<NEWL>><<NEWL>>__all__ = [<<NEWL>>    # Old names.<<NEWL>>    'HasArg',<<NEWL>>    'HasCompletions',<<NEWL>>    'HasFocus',<<NEWL>>    'HasSelection',<<NEWL>>    'HasValidationError',<<NEWL>>    'IsDone',<<NEWL>>    'IsReadOnly',<<NEWL>>    'IsMultiline',<<NEWL>>    'RendererHeightIsKnown',<<NEWL>>    'InEditingMode',<<NEWL>>    'InPasteMode',<<NEWL>><<NEWL>>    'ViMode',<<NEWL>>    'ViNavigationMode',<<NEWL>>    'ViInsertMode',<<NEWL>>    'ViInsertMultipleMode',<<NEWL>>    'ViReplaceMode',<<NEWL>>    'ViSelectionMode',<<NEWL>>    'ViWaitingForTextObjectMode',<<NEWL>>    'ViDigraphMode',<<NEWL>><<NEWL>>    'EmacsMode',<<NEWL>>    'EmacsInsertMode',<<NEWL>>    'EmacsSelectionMode',<<NEWL>><<NEWL>>    'IsSearching',<<NEWL>>    'HasSearch',<<NEWL>>    'ControlIsSearchable',<<NEWL>>]<<NEWL>><<NEWL>># Keep the original classnames for backwards compatibility.<<NEWL>>HasValidationError = lambda: has_validation_error<<NEWL>>HasArg = lambda: has_arg<<NEWL>>IsDone = lambda: is_done<<NEWL>>RendererHeightIsKnown = lambda: renderer_height_is_known<<NEWL>>ViNavigationMode = lambda: vi_navigation_mode<<NEWL>>InPasteMode = lambda: in_paste_mode<<NEWL>>EmacsMode = lambda: emacs_mode<<NEWL>>EmacsInsertMode = lambda: emacs_insert_mode<<NEWL>>ViMode = lambda: vi_mode<<NEWL>>IsSearching = lambda: is_searching<<NEWL>>HasSearch = lambda: is_searching<<NEWL>>ControlIsSearchable = lambda: control_is_searchable<<NEWL>>EmacsSelectionMode = lambda: emacs_selection_mode<<NEWL>>ViDigraphMode = lambda: vi_digraph_mode<<NEWL>>ViWaitingForTextObjectMode = lambda: vi_waiting_for_text_object_mode<<NEWL>>ViSelectionMode = lambda: vi_selection_mode<<NEWL>>ViReplaceMode = lambda: vi_replace_mode<<NEWL>>ViInsertMultipleMode = lambda: vi_insert_multiple_mode<<NEWL>>ViInsertMode = lambda: vi_insert_mode<<NEWL>>HasSelection = lambda: has_selection<<NEWL>>HasCompletions = lambda: has_completions<<NEWL>>IsReadOnly = lambda: is_read_only<<NEWL>>IsMultiline = lambda: is_multiline<<NEWL>><<NEWL>>HasFocus = has_focus  # No lambda here! (Has_focus is callable that returns a callable.)<<NEWL>>InEditingMode = in_editing_mode
237	adjudicated	3	#<<NEWL>># This file is part of pyasn1-modules software.<<NEWL>>#<<NEWL>># Created by Russ Housley with assistance from asn1ate v.0.6.0.<<NEWL>>#<<NEWL>># Copyright (c) 2019, Vigil Security, LLC<<NEWL>># License: http://snmplabs.com/pyasn1/license.html<<NEWL>>#<<NEWL>># CMS Encrypted Key Package Content Type<<NEWL>>#<<NEWL>># ASN.1 source from:<<NEWL>># https://www.rfc-editor.org/rfc/rfc6032.txt<<NEWL>>#<<NEWL>><<NEWL>>from pyasn1.type import namedtype<<NEWL>>from pyasn1.type import tag<<NEWL>>from pyasn1.type import univ<<NEWL>><<NEWL>>from pyasn1_modules import rfc5652<<NEWL>>from pyasn1_modules import rfc5083<<NEWL>><<NEWL>><<NEWL>># Content Decryption Key Identifier attribute<<NEWL>><<NEWL>>id_aa_KP_contentDecryptKeyID = univ.ObjectIdentifier('2.16.840.1.101.2.1.5.66')<<NEWL>><<NEWL>>class ContentDecryptKeyID(univ.OctetString):<<NEWL>>    pass<<NEWL>><<NEWL>>aa_content_decrypt_key_identifier = rfc5652.Attribute()<<NEWL>>aa_content_decrypt_key_identifier['attrType'] = id_aa_KP_contentDecryptKeyID<<NEWL>>aa_content_decrypt_key_identifier['attrValues'][0] = ContentDecryptKeyID()<<NEWL>><<NEWL>><<NEWL>># Encrypted Key Package Content Type<<NEWL>><<NEWL>>id_ct_KP_encryptedKeyPkg = univ.ObjectIdentifier('2.16.840.1.101.2.1.2.78.2')<<NEWL>><<NEWL>>class EncryptedKeyPackage(univ.Choice):<<NEWL>>    pass<<NEWL>><<NEWL>>EncryptedKeyPackage.componentType = namedtype.NamedTypes(<<NEWL>>    namedtype.NamedType('encrypted', rfc5652.EncryptedData()),<<NEWL>>    namedtype.NamedType('enveloped', rfc5652.EnvelopedData().subtype(<<NEWL>>        implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 0))),<<NEWL>>    namedtype.NamedType('authEnveloped', rfc5083.AuthEnvelopedData().subtype(<<NEWL>>        implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 1)))<<NEWL>>)<<NEWL>><<NEWL>><<NEWL>># Map of Attribute Type OIDs to Attributes are<<NEWL>># added to the ones that are in rfc5652.py<<NEWL>><<NEWL>>_cmsAttributesMapUpdate = {<<NEWL>>    id_aa_KP_contentDecryptKeyID: ContentDecryptKeyID(),<<NEWL>>}<<NEWL>><<NEWL>>rfc5652.cmsAttributesMap.update(_cmsAttributesMapUpdate)<<NEWL>><<NEWL>><<NEWL>># Map of Content Type OIDs to Content Types are<<NEWL>># added to the ones that are in rfc5652.py<<NEWL>><<NEWL>>_cmsContentTypesMapUpdate = {<<NEWL>>    id_ct_KP_encryptedKeyPkg: EncryptedKeyPackage(),<<NEWL>>}<<NEWL>><<NEWL>>rfc5652.cmsContentTypesMap.update(_cmsContentTypesMapUpdate)
377	adjudicated	1	"######################## BEGIN LICENSE BLOCK ########################<<NEWL>># The Original Code is mozilla.org code.<<NEWL>>#<<NEWL>># The Initial Developer of the Original Code is<<NEWL>># Netscape Communications Corporation.<<NEWL>># Portions created by the Initial Developer are Copyright (C) 1998<<NEWL>># the Initial Developer. All Rights Reserved.<<NEWL>>#<<NEWL>># Contributor(s):<<NEWL>>#   Mark Pilgrim - port to Python<<NEWL>>#<<NEWL>># This library is free software; you can redistribute it and/or<<NEWL>># modify it under the terms of the GNU Lesser General Public<<NEWL>># License as published by the Free Software Foundation; either<<NEWL>># version 2.1 of the License, or (at your option) any later version.<<NEWL>>#<<NEWL>># This library is distributed in the hope that it will be useful,<<NEWL>># but WITHOUT ANY WARRANTY; without even the implied warranty of<<NEWL>># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU<<NEWL>># Lesser General Public License for more details.<<NEWL>>#<<NEWL>># You should have received a copy of the GNU Lesser General Public<<NEWL>># License along with this library; if not, write to the Free Software<<NEWL>># Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA<<NEWL>># 02110-1301  USA<<NEWL>>######################### END LICENSE BLOCK #########################<<NEWL>><<NEWL>>from .chardistribution import EUCKRDistributionAnalysis<<NEWL>>from .codingstatemachine import CodingStateMachine<<NEWL>>from .mbcharsetprober import MultiByteCharSetProber<<NEWL>>from .mbcssm import CP949_SM_MODEL<<NEWL>><<NEWL>><<NEWL>>class CP949Prober(MultiByteCharSetProber):<<NEWL>>    def __init__(self):<<NEWL>>        super().__init__()<<NEWL>>        self.coding_sm = CodingStateMachine(CP949_SM_MODEL)<<NEWL>>        # NOTE: CP949 is a superset of EUC-KR, so the distribution should be<<NEWL>>        #       not different.<<NEWL>>        self.distribution_analyzer = EUCKRDistributionAnalysis()<<NEWL>>        self.reset()<<NEWL>><<NEWL>>    @property<<NEWL>>    def charset_name(self):<<NEWL>>        return ""CP949""<<NEWL>><<NEWL>>    @property<<NEWL>>    def language(self):<<NEWL>>        return ""Korean"""
266	adjudicated	1	"# Copyright (c) Meta Platforms, Inc. and affiliates.<<NEWL>>#<<NEWL>># This source code is licensed under the MIT license found in the<<NEWL>># LICENSE file in the root directory of this source tree.<<NEWL>><<NEWL>>from viktor._vendor.libcst._parser.grammar import _should_include<<NEWL>>from viktor._vendor.libcst._parser.parso.utils import PythonVersionInfo<<NEWL>>from viktor._vendor.libcst.testing.utils import data_provider, UnitTest<<NEWL>><<NEWL>><<NEWL>>class VersionCompareTest(UnitTest):<<NEWL>>    @data_provider(<<NEWL>>        (<<NEWL>>            # Simple equality<<NEWL>>            (""==3.6"", PythonVersionInfo(3, 6), True),<<NEWL>>            (""!=3.6"", PythonVersionInfo(3, 6), False),<<NEWL>>            # Equal or GT/LT<<NEWL>>            ("">=3.6"", PythonVersionInfo(3, 5), False),<<NEWL>>            ("">=3.6"", PythonVersionInfo(3, 6), True),<<NEWL>>            ("">=3.6"", PythonVersionInfo(3, 7), True),<<NEWL>>            (""<=3.6"", PythonVersionInfo(3, 5), True),<<NEWL>>            (""<=3.6"", PythonVersionInfo(3, 6), True),<<NEWL>>            (""<=3.6"", PythonVersionInfo(3, 7), False),<<NEWL>>            # GT/LT<<NEWL>>            ("">3.6"", PythonVersionInfo(3, 5), False),<<NEWL>>            ("">3.6"", PythonVersionInfo(3, 6), False),<<NEWL>>            ("">3.6"", PythonVersionInfo(3, 7), True),<<NEWL>>            (""<3.6"", PythonVersionInfo(3, 5), True),<<NEWL>>            (""<3.6"", PythonVersionInfo(3, 6), False),<<NEWL>>            (""<3.6"", PythonVersionInfo(3, 7), False),<<NEWL>>            # Multiple checks<<NEWL>>            ("">3.6,<3.8"", PythonVersionInfo(3, 6), False),<<NEWL>>            ("">3.6,<3.8"", PythonVersionInfo(3, 7), True),<<NEWL>>            ("">3.6,<3.8"", PythonVersionInfo(3, 8), False),<<NEWL>>        )<<NEWL>>    )<<NEWL>>    def test_tokenize(<<NEWL>>        self,<<NEWL>>        requested_version: str,<<NEWL>>        actual_version: PythonVersionInfo,<<NEWL>>        expected_result: bool,<<NEWL>>    ) -> None:<<NEWL>>        self.assertEqual(<<NEWL>>            _should_include(requested_version, actual_version), expected_result<<NEWL>>        )"
326	adjudicated	2	"""""""<<NEWL>>    pygments.lexers.pointless<<NEWL>>    ~~~~~~~~~~~~~~~~~~~~~~~~~<<NEWL>><<NEWL>>    Lexers for Pointless.<<NEWL>><<NEWL>>    :copyright: Copyright 2006-2022 by the Pygments team, see AUTHORS.<<NEWL>>    :license: BSD, see LICENSE for details.<<NEWL>>""""""<<NEWL>><<NEWL>>from pygments.lexer import RegexLexer, words<<NEWL>>from pygments.token import Comment, Error, Keyword, Name, Number, Operator, \<<NEWL>>    Punctuation, String, Text<<NEWL>><<NEWL>>__all__ = ['PointlessLexer']<<NEWL>><<NEWL>><<NEWL>>class PointlessLexer(RegexLexer):<<NEWL>>    """"""<<NEWL>>    For Pointless source code.<<NEWL>><<NEWL>>    .. versionadded:: 2.7<<NEWL>>    """"""<<NEWL>><<NEWL>>    name = 'Pointless'<<NEWL>>    url = 'https://ptls.dev'<<NEWL>>    aliases = ['pointless']<<NEWL>>    filenames = ['*.ptls']<<NEWL>><<NEWL>>    ops = words([<<NEWL>>        ""+"", ""-"", ""*"", ""/"", ""**"", ""%"", ""+="", ""-="", ""*="",<<NEWL>>        ""/="", ""**="", ""%="", ""|>"", ""="", ""=="", ""!="", ""<"", "">"",<<NEWL>>        ""<="", "">="", ""=>"", ""$"", ""++"",<<NEWL>>    ])<<NEWL>><<NEWL>>    keywords = words([<<NEWL>>        ""if"", ""then"", ""else"", ""where"", ""with"", ""cond"",<<NEWL>>        ""case"", ""and"", ""or"", ""not"", ""in"", ""as"", ""for"",<<NEWL>>        ""requires"", ""throw"", ""try"", ""catch"", ""when"",<<NEWL>>        ""yield"", ""upval"",<<NEWL>>    ], suffix=r'\b')<<NEWL>><<NEWL>>    tokens = {<<NEWL>>        'root': [<<NEWL>>            (r'[ \n\r]+', Text),<<NEWL>>            (r'--.*$', Comment.Single),<<NEWL>>            (r'""""""', String, 'multiString'),<<NEWL>>            (r'""', String, 'string'),<<NEWL>>            (r'[\[\](){}:;,.]', Punctuation),<<NEWL>>            (ops, Operator),<<NEWL>>            (keywords, Keyword),<<NEWL>>            (r'\d+|\d*\.\d+', Number),<<NEWL>>            (r'(true|false)\b', Name.Builtin),<<NEWL>>            (r'[A-Z][a-zA-Z0-9]*\b', String.Symbol),<<NEWL>>            (r'output\b', Name.Variable.Magic),<<NEWL>>            (r'(export|import)\b', Keyword.Namespace),<<NEWL>>            (r'[a-z][a-zA-Z0-9]*\b', Name.Variable)<<NEWL>>        ],<<NEWL>>        'multiString': [<<NEWL>>            (r'\\.', String.Escape),<<NEWL>>            (r'""""""', String, '#pop'),<<NEWL>>            (r'""', String),<<NEWL>>            (r'[^\\""]+', String),<<NEWL>>        ],<<NEWL>>        'string': [<<NEWL>>            (r'\\.', String.Escape),<<NEWL>>            (r'""', String, '#pop'),<<NEWL>>            (r'\n', Error),<<NEWL>>            (r'[^\\""]+', String),<<NEWL>>        ],<<NEWL>>    }"
104	adjudicated	0	"from environs import Env<<NEWL>><<NEWL>>from api import MentorsAPI<<NEWL>><<NEWL>><<NEWL>>def main() -> None:<<NEWL>>    env = Env()<<NEWL>>    env.read_env()<<NEWL>><<NEWL>>    mentors_api = MentorsAPI(env.str('DVMN_USERNAME'), env.str('DVMN_PASSWORD'))<<NEWL>>    mentor_uuid = env.str('MENTOR_UUID')<<NEWL>><<NEWL>>    orders = mentors_api.get_mentor_orders(mentor_uuid)<<NEWL>><<NEWL>>    for order in orders:<<NEWL>>        if not order['is_active']:<<NEWL>>            continue<<NEWL>><<NEWL>>        notes = order['student']['notes']<<NEWL>>        proj_notes = [<<NEWL>>            n for n in notes if <<NEWL>>            ' ' in n['content']<<NEWL>>            and not n['is_hidden']<<NEWL>>        ]<<NEWL>>        if not proj_notes:<<NEWL>>            continue<<NEWL>><<NEWL>>        tasks = mentors_api.get_study_program_by_order_uuid(order['uuid'])<<NEWL>>        project_task = None<<NEWL>>        for task in tasks:<<NEWL>>            if any([<<NEWL>>                ' ' not in task['trainer']['title'],<<NEWL>>                task['is_completed']<<NEWL>>            ]):<<NEWL>>                continue<<NEWL>><<NEWL>>            project_task = task<<NEWL>>            break<<NEWL>>        <<NEWL>>        if not project_task:<<NEWL>>            print(f': {order[""uuid""]}    .')<<NEWL>>            continue<<NEWL>>        <<NEWL>>        try:<<NEWL>>            plan_uuid = mentors_api.create_weekly_plan(<<NEWL>>                order['uuid'],<<NEWL>>                project_task['uuid'],<<NEWL>>                project_task['execution_time']<<NEWL>>            )<<NEWL>>            mentors_api.create_gist(plan_uuid)<<NEWL>>            mentors_api.give_weekly_plan(<<NEWL>>                order['uuid'],<<NEWL>>                project_task['uuid'],<<NEWL>>                project_task['execution_time'],<<NEWL>>                plan_uuid<<NEWL>>            )<<NEWL>>            mentors_api.update_gist(plan_uuid)<<NEWL>>        except Exception as err:<<NEWL>>            print(f'-     : {order[""uuid""]}')<<NEWL>>        else:<<NEWL>>            for n in proj_notes:<<NEWL>>                mentors_api.close_note(n['uuid'])<<NEWL>><<NEWL>>            mentors_api.add_note(<<NEWL>>                student_uuid=order['student']['profile']['uuid'],<<NEWL>>                comment='$:    !  ?)'<<NEWL>>            )<<NEWL>><<NEWL>><<NEWL>><<NEWL>>if __name__ == '__main__':<<NEWL>>    main()"
295	adjudicated	3	"from typing import Any, Dict, Optional, Union<<NEWL>>from warnings import warn<<NEWL>><<NEWL>>from .api import from_bytes<<NEWL>>from .constant import CHARDET_CORRESPONDENCE<<NEWL>><<NEWL>><<NEWL>>def detect(<<NEWL>>    byte_str: bytes, should_rename_legacy: bool = False, **kwargs: Any<<NEWL>>) -> Dict[str, Optional[Union[str, float]]]:<<NEWL>>    """"""<<NEWL>>    chardet legacy method<<NEWL>>    Detect the encoding of the given byte string. It should be mostly backward-compatible.<<NEWL>>    Encoding name will match Chardet own writing whenever possible. (Not on encoding name unsupported by it)<<NEWL>>    This function is deprecated and should be used to migrate your project easily, consult the documentation for<<NEWL>>    further information. Not planned for removal.<<NEWL>><<NEWL>>    :param byte_str:     The byte sequence to examine.<<NEWL>>    :param should_rename_legacy:  Should we rename legacy encodings<<NEWL>>                                  to their more modern equivalents?<<NEWL>>    """"""<<NEWL>>    if len(kwargs):<<NEWL>>        warn(<<NEWL>>            f""charset-normalizer disregard arguments '{','.join(list(kwargs.keys()))}' in legacy function detect()""<<NEWL>>        )<<NEWL>><<NEWL>>    if not isinstance(byte_str, (bytearray, bytes)):<<NEWL>>        raise TypeError(  # pragma: nocover<<NEWL>>            ""Expected object of type bytes or bytearray, got: ""<<NEWL>>            ""{0}"".format(type(byte_str))<<NEWL>>        )<<NEWL>><<NEWL>>    if isinstance(byte_str, bytearray):<<NEWL>>        byte_str = bytes(byte_str)<<NEWL>><<NEWL>>    r = from_bytes(byte_str).best()<<NEWL>><<NEWL>>    encoding = r.encoding if r is not None else None<<NEWL>>    language = r.language if r is not None and r.language != ""Unknown"" else """"<<NEWL>>    confidence = 1.0 - r.chaos if r is not None else None<<NEWL>><<NEWL>>    # Note: CharsetNormalizer does not return 'UTF-8-SIG' as the sig get stripped in the detection/normalization process<<NEWL>>    # but chardet does return 'utf-8-sig' and it is a valid codec name.<<NEWL>>    if r is not None and encoding == ""utf_8"" and r.bom:<<NEWL>>        encoding += ""_sig""<<NEWL>><<NEWL>>    if should_rename_legacy is False and encoding in CHARDET_CORRESPONDENCE:<<NEWL>>        encoding = CHARDET_CORRESPONDENCE[encoding]<<NEWL>><<NEWL>>    return {<<NEWL>>        ""encoding"": encoding,<<NEWL>>        ""language"": language,<<NEWL>>        ""confidence"": confidence,<<NEWL>>    }"
44	adjudicated	0	# flake8: noqa<<NEWL>># errmsg.h<<NEWL>>CR_ERROR_FIRST = 2000<<NEWL>>CR_UNKNOWN_ERROR = 2000<<NEWL>>CR_SOCKET_CREATE_ERROR = 2001<<NEWL>>CR_CONNECTION_ERROR = 2002<<NEWL>>CR_CONN_HOST_ERROR = 2003<<NEWL>>CR_IPSOCK_ERROR = 2004<<NEWL>>CR_UNKNOWN_HOST = 2005<<NEWL>>CR_SERVER_GONE_ERROR = 2006<<NEWL>>CR_VERSION_ERROR = 2007<<NEWL>>CR_OUT_OF_MEMORY = 2008<<NEWL>>CR_WRONG_HOST_INFO = 2009<<NEWL>>CR_LOCALHOST_CONNECTION = 2010<<NEWL>>CR_TCP_CONNECTION = 2011<<NEWL>>CR_SERVER_HANDSHAKE_ERR = 2012<<NEWL>>CR_SERVER_LOST = 2013<<NEWL>>CR_COMMANDS_OUT_OF_SYNC = 2014<<NEWL>>CR_NAMEDPIPE_CONNECTION = 2015<<NEWL>>CR_NAMEDPIPEWAIT_ERROR = 2016<<NEWL>>CR_NAMEDPIPEOPEN_ERROR = 2017<<NEWL>>CR_NAMEDPIPESETSTATE_ERROR = 2018<<NEWL>>CR_CANT_READ_CHARSET = 2019<<NEWL>>CR_NET_PACKET_TOO_LARGE = 2020<<NEWL>>CR_EMBEDDED_CONNECTION = 2021<<NEWL>>CR_PROBE_SLAVE_STATUS = 2022<<NEWL>>CR_PROBE_SLAVE_HOSTS = 2023<<NEWL>>CR_PROBE_SLAVE_CONNECT = 2024<<NEWL>>CR_PROBE_MASTER_CONNECT = 2025<<NEWL>>CR_SSL_CONNECTION_ERROR = 2026<<NEWL>>CR_MALFORMED_PACKET = 2027<<NEWL>>CR_WRONG_LICENSE = 2028<<NEWL>><<NEWL>>CR_NULL_POINTER = 2029<<NEWL>>CR_NO_PREPARE_STMT = 2030<<NEWL>>CR_PARAMS_NOT_BOUND = 2031<<NEWL>>CR_DATA_TRUNCATED = 2032<<NEWL>>CR_NO_PARAMETERS_EXISTS = 2033<<NEWL>>CR_INVALID_PARAMETER_NO = 2034<<NEWL>>CR_INVALID_BUFFER_USE = 2035<<NEWL>>CR_UNSUPPORTED_PARAM_TYPE = 2036<<NEWL>><<NEWL>>CR_SHARED_MEMORY_CONNECTION = 2037<<NEWL>>CR_SHARED_MEMORY_CONNECT_REQUEST_ERROR = 2038<<NEWL>>CR_SHARED_MEMORY_CONNECT_ANSWER_ERROR = 2039<<NEWL>>CR_SHARED_MEMORY_CONNECT_FILE_MAP_ERROR = 2040<<NEWL>>CR_SHARED_MEMORY_CONNECT_MAP_ERROR = 2041<<NEWL>>CR_SHARED_MEMORY_FILE_MAP_ERROR = 2042<<NEWL>>CR_SHARED_MEMORY_MAP_ERROR = 2043<<NEWL>>CR_SHARED_MEMORY_EVENT_ERROR = 2044<<NEWL>>CR_SHARED_MEMORY_CONNECT_ABANDONED_ERROR = 2045<<NEWL>>CR_SHARED_MEMORY_CONNECT_SET_ERROR = 2046<<NEWL>>CR_CONN_UNKNOW_PROTOCOL = 2047<<NEWL>>CR_INVALID_CONN_HANDLE = 2048<<NEWL>>CR_SECURE_AUTH = 2049<<NEWL>>CR_FETCH_CANCELED = 2050<<NEWL>>CR_NO_DATA = 2051<<NEWL>>CR_NO_STMT_METADATA = 2052<<NEWL>>CR_NO_RESULT_SET = 2053<<NEWL>>CR_NOT_IMPLEMENTED = 2054<<NEWL>>CR_SERVER_LOST_EXTENDED = 2055<<NEWL>>CR_STMT_CLOSED = 2056<<NEWL>>CR_NEW_STMT_METADATA = 2057<<NEWL>>CR_ALREADY_CONNECTED = 2058<<NEWL>>CR_AUTH_PLUGIN_CANNOT_LOAD = 2059<<NEWL>>CR_DUPLICATE_CONNECTION_ATTR = 2060<<NEWL>>CR_AUTH_PLUGIN_ERR = 2061<<NEWL>>CR_ERROR_LAST = 2061
155	adjudicated	2	"import json<<NEWL>>import requests<<NEWL>><<NEWL>><<NEWL>>class APIMng:<<NEWL>>    def __init__(self, melexID):<<NEWL>>        self.Melex_ID = melexID<<NEWL>>        self.Requests_endpoint = {<<NEWL>>            'url_recived': 'http://213.97.17.253:9000/requests/state/recived',<<NEWL>>            'url_put': 'http://213.97.17.253:9000/request',<<NEWL>>            'url_progress': 'http://213.97.17.253:9000/requests/state/progress',<<NEWL>>            'json': None,<<NEWL>>            'id': None<<NEWL>>        }<<NEWL>>        self.ParametersCCAA_endpoint = {<<NEWL>>            'url': 'http://213.97.17.253:9000/parametersCA/',<<NEWL>>            'json': None<<NEWL>>        }<<NEWL>>        self.estate = None<<NEWL>><<NEWL>>    def __del__(self):<<NEWL>>        pass<<NEWL>><<NEWL>>    # Pedir tareas REQUESTS/GET<<NEWL>>    def get_requests_api(self):<<NEWL>>        r = requests.get(url=self.Requests_endpoint['url_recived'])<<NEWL>>        self.Requests_endpoint['json'] = json.loads(r.text)<<NEWL>>        return self.Requests_endpoint['json']<<NEWL>><<NEWL>>    def task_progress(self):<<NEWL>>        r = requests.get(url=self.Requests_endpoint['url_progress'])<<NEWL>>        print(r.text)<<NEWL>>        if isinstance(json.loads(r.text), dict):<<NEWL>>            return None, False<<NEWL>>        else:<<NEWL>>            return json.loads(r.text), True<<NEWL>><<NEWL>>    # Mandar actualizacin tareas (progreso o acabada) REQUESTS/PUT<<NEWL>>    def put_requests_api(self):<<NEWL>>        print(self.Requests_endpoint['url_put'] + '/' + str(self.Requests_endpoint['id']), self.Requests_endpoint['json'])<<NEWL>>        r = requests.put(self.Requests_endpoint['url_put'] + '/' + str(self.Requests_endpoint['id']), json=self.Requests_endpoint['json'])<<NEWL>>        print(r)<<NEWL>><<NEWL>>    # Mandar parmetros del vehculo (PARAMETERScar/PUT)<<NEWL>>    def put_ParametersCCAA_api(self):<<NEWL>>        r = requests.put(self.ParametersCCAA_endpoint['url'] + self.Melex_ID, json=self.ParametersCCAA_endpoint['json'])<<NEWL>><<NEWL>>    # Crear JSON para hacer el put al endpoint Requests<<NEWL>>    def requests_put_json(self, data, id):<<NEWL>>        self.Requests_endpoint[""json""] = data<<NEWL>>        self.Requests_endpoint[""id""] = id<<NEWL>><<NEWL>>    def create_ParametersCCAA_json(self, data):<<NEWL>>        self.ParametersCCAA_endpoint[""json""] = data<<NEWL>><<NEWL>>"
15	adjudicated	3	"import sys<<NEWL>><<NEWL>><<NEWL>>class VendorImporter:<<NEWL>>    """"""<<NEWL>>    A PEP 302 meta path importer for finding optionally-vendored<<NEWL>>    or otherwise naturally-installed packages from root_name.<<NEWL>>    """"""<<NEWL>><<NEWL>>    def __init__(self, root_name, vendored_names=(), vendor_pkg=None):<<NEWL>>        self.root_name = root_name<<NEWL>>        self.vendored_names = set(vendored_names)<<NEWL>>        self.vendor_pkg = vendor_pkg or root_name.replace('extern', '_vendor')<<NEWL>><<NEWL>>    @property<<NEWL>>    def search_path(self):<<NEWL>>        """"""<<NEWL>>        Search first the vendor package then as a natural package.<<NEWL>>        """"""<<NEWL>>        yield self.vendor_pkg + '.'<<NEWL>>        yield ''<<NEWL>><<NEWL>>    def find_module(self, fullname, path=None):<<NEWL>>        """"""<<NEWL>>        Return self when fullname starts with root_name and the<<NEWL>>        target module is one vendored through this importer.<<NEWL>>        """"""<<NEWL>>        root, base, target = fullname.partition(self.root_name + '.')<<NEWL>>        if root:<<NEWL>>            return<<NEWL>>        if not any(map(target.startswith, self.vendored_names)):<<NEWL>>            return<<NEWL>>        return self<<NEWL>><<NEWL>>    def load_module(self, fullname):<<NEWL>>        """"""<<NEWL>>        Iterate over the search path to locate and load fullname.<<NEWL>>        """"""<<NEWL>>        root, base, target = fullname.partition(self.root_name + '.')<<NEWL>>        for prefix in self.search_path:<<NEWL>>            try:<<NEWL>>                extant = prefix + target<<NEWL>>                __import__(extant)<<NEWL>>                mod = sys.modules[extant]<<NEWL>>                sys.modules[fullname] = mod<<NEWL>>                return mod<<NEWL>>            except ImportError:<<NEWL>>                pass<<NEWL>>        else:<<NEWL>>            raise ImportError(<<NEWL>>                ""The '{target}' package is required; ""<<NEWL>>                ""normally this is bundled with this package so if you get ""<<NEWL>>                ""this warning, consult the packager of your ""<<NEWL>>                ""distribution."".format(**locals())<<NEWL>>            )<<NEWL>><<NEWL>>    def install(self):<<NEWL>>        """"""<<NEWL>>        Install this importer into sys.meta_path if not already present.<<NEWL>>        """"""<<NEWL>>        if self not in sys.meta_path:<<NEWL>>            sys.meta_path.append(self)<<NEWL>><<NEWL>><<NEWL>>names = 'packaging', 'pyparsing', 'six', 'appdirs'<<NEWL>>VendorImporter(__name__, names).install()"
384	adjudicated	0	"import esphome.codegen as cg<<NEWL>>import esphome.config_validation as cv<<NEWL>>from esphome import pins<<NEWL>>from esphome.components import display<<NEWL>>from esphome.const import (<<NEWL>>    CONF_BRIGHTNESS,<<NEWL>>    CONF_EXTERNAL_VCC,<<NEWL>>    CONF_LAMBDA,<<NEWL>>    CONF_MODEL,<<NEWL>>    CONF_RESET_PIN,<<NEWL>>)<<NEWL>><<NEWL>>CODEOWNERS = [""@kbx81""]<<NEWL>><<NEWL>>ssd1325_base_ns = cg.esphome_ns.namespace(""ssd1325_base"")<<NEWL>>SSD1325 = ssd1325_base_ns.class_(""SSD1325"", cg.PollingComponent, display.DisplayBuffer)<<NEWL>>SSD1325Model = ssd1325_base_ns.enum(""SSD1325Model"")<<NEWL>><<NEWL>>MODELS = {<<NEWL>>    ""SSD1325_128X32"": SSD1325Model.SSD1325_MODEL_128_32,<<NEWL>>    ""SSD1325_128X64"": SSD1325Model.SSD1325_MODEL_128_64,<<NEWL>>    ""SSD1325_96X16"": SSD1325Model.SSD1325_MODEL_96_16,<<NEWL>>    ""SSD1325_64X48"": SSD1325Model.SSD1325_MODEL_64_48,<<NEWL>>    ""SSD1327_128X128"": SSD1325Model.SSD1327_MODEL_128_128,<<NEWL>>}<<NEWL>><<NEWL>>SSD1325_MODEL = cv.enum(MODELS, upper=True, space=""_"")<<NEWL>><<NEWL>>SSD1325_SCHEMA = display.FULL_DISPLAY_SCHEMA.extend(<<NEWL>>    {<<NEWL>>        cv.Required(CONF_MODEL): SSD1325_MODEL,<<NEWL>>        cv.Optional(CONF_RESET_PIN): pins.gpio_output_pin_schema,<<NEWL>>        cv.Optional(CONF_BRIGHTNESS, default=1.0): cv.percentage,<<NEWL>>        cv.Optional(CONF_EXTERNAL_VCC): cv.boolean,<<NEWL>>    }<<NEWL>>).extend(cv.polling_component_schema(""1s""))<<NEWL>><<NEWL>><<NEWL>>async def setup_ssd1325(var, config):<<NEWL>>    await cg.register_component(var, config)<<NEWL>>    await display.register_display(var, config)<<NEWL>><<NEWL>>    cg.add(var.set_model(config[CONF_MODEL]))<<NEWL>>    if CONF_RESET_PIN in config:<<NEWL>>        reset = await cg.gpio_pin_expression(config[CONF_RESET_PIN])<<NEWL>>        cg.add(var.set_reset_pin(reset))<<NEWL>>    if CONF_BRIGHTNESS in config:<<NEWL>>        cg.add(var.init_brightness(config[CONF_BRIGHTNESS]))<<NEWL>>    if CONF_EXTERNAL_VCC in config:<<NEWL>>        cg.add(var.set_external_vcc(config[CONF_EXTERNAL_VCC]))<<NEWL>>    if CONF_LAMBDA in config:<<NEWL>>        lambda_ = await cg.process_lambda(<<NEWL>>            config[CONF_LAMBDA], [(display.DisplayBufferRef, ""it"")], return_type=cg.void<<NEWL>>        )<<NEWL>>        cg.add(var.set_writer(lambda_))"
83	adjudicated	3	"#!/usr/bin/env python<<NEWL>># Copyright 2021 Google, Inc<<NEWL>>#<<NEWL>># Licensed under the Apache License, Version 2.0 (the ""License"");<<NEWL>># you may not use this file except in compliance with the License.<<NEWL>># You may obtain a copy of the License at<<NEWL>>#<<NEWL>>#      http://www.apache.org/licenses/LICENSE-2.0<<NEWL>>#<<NEWL>># Unless required by applicable law or agreed to in writing, software<<NEWL>># distributed under the License is distributed on an ""AS IS"" BASIS,<<NEWL>># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<<NEWL>># See the License for the specific language governing permissions and<<NEWL>># limitations under the License.<<NEWL>>#<<NEWL>># All Rights Reserved.<<NEWL>><<NEWL>># [START recaptcha_enterprise_get_site_key]<<NEWL>>from google.cloud import recaptchaenterprise_v1<<NEWL>><<NEWL>><<NEWL>>def get_site_key(project_id: str, recaptcha_site_key: str) -> None:<<NEWL>>    """"""<<NEWL>>    Get the reCAPTCHA site key present under the project ID.<<NEWL>><<NEWL>>    Args:<<NEWL>>    project_id: GCloud Project ID.<<NEWL>>    recaptcha_site_key: Specify the site key to get the details.<<NEWL>>    """"""<<NEWL>><<NEWL>>    client = recaptchaenterprise_v1.RecaptchaEnterpriseServiceClient()<<NEWL>><<NEWL>>    # Construct the key details.<<NEWL>>    key_name = f""projects/{project_id}/keys/{recaptcha_site_key}""<<NEWL>><<NEWL>>    request = recaptchaenterprise_v1.GetKeyRequest()<<NEWL>>    request.name = key_name<<NEWL>><<NEWL>>    key = client.get_key(request)<<NEWL>>    print(""Successfully obtained the key !"" + key.name)<<NEWL>><<NEWL>><<NEWL>># [END recaptcha_enterprise_get_site_key]<<NEWL>><<NEWL>><<NEWL>>if __name__ == ""__main__"":<<NEWL>>    import google.auth<<NEWL>>    import google.auth.exceptions<<NEWL>><<NEWL>>    # TODO(developer): Replace the below variables before running<<NEWL>>    try:<<NEWL>>        default_project_id = google.auth.default()[1]<<NEWL>>        recaptcha_site_key = ""recaptcha_site_key""<<NEWL>>    except google.auth.exceptions.DefaultCredentialsError:<<NEWL>>        print(<<NEWL>>            ""Please use `gcloud auth application-default login` ""<<NEWL>>            ""or set GOOGLE_APPLICATION_CREDENTIALS to use this script.""<<NEWL>>        )<<NEWL>>    else:<<NEWL>>        get_site_key(default_project_id, recaptcha_site_key)"
312	adjudicated	4	"#!../env.py<<NEWL>>#<<NEWL>># SPDX-License-Identifier: BSD-3-Clause<<NEWL>># Copyright 2020, Intel Corporation<<NEWL>><<NEWL>>import testframework as t<<NEWL>>from testframework import granularity as g<<NEWL>>import futils<<NEWL>>import os<<NEWL>><<NEWL>><<NEWL>># All test cases in pmem2_persist_valgrind use Valgrind, which is not available<<NEWL>># on Windows systems.<<NEWL>>@t.windows_exclude<<NEWL>>@t.require_valgrind_enabled('pmemcheck')<<NEWL>># XXX In the match file, there are two possible numbers of errors. It varies<<NEWL>># from compiler to compiler. There should be only one number when pmemcheck<<NEWL>># will be fixed. Please also remove the below requirement after pmemcheck fix.<<NEWL>># https://github.com/pmem/valgrind/pull/76<<NEWL>>@g.require_granularity(g.CL_OR_LESS)<<NEWL>>class PMEM2_PERSIST(t.Test):<<NEWL>>    test_type = t.Medium<<NEWL>>    available_granularity = None<<NEWL>><<NEWL>>    def run(self, ctx):<<NEWL>>        filepath = ctx.create_holey_file(2 * t.MiB, 'testfile')<<NEWL>>        ctx.exec('pmem2_persist_valgrind', self.test_case, filepath)<<NEWL>><<NEWL>><<NEWL>>class TEST0(PMEM2_PERSIST):<<NEWL>>    """"""persist continuous data in a range of pmem""""""<<NEWL>>    test_case = ""test_persist_continuous_range""<<NEWL>><<NEWL>><<NEWL>>class TEST1(PMEM2_PERSIST):<<NEWL>>    """"""persist discontinuous data in a range of pmem""""""<<NEWL>>    test_case = ""test_persist_discontinuous_range""<<NEWL>><<NEWL>><<NEWL>>class TEST2(PMEM2_PERSIST):<<NEWL>>    """"""persist part of discontinuous data in a range of pmem""""""<<NEWL>>    test_case = ""test_persist_discontinuous_range_partially""<<NEWL>><<NEWL>>    def run(self, ctx):<<NEWL>>        filepath = ctx.create_holey_file(16 * t.KiB, 'testfile')<<NEWL>>        ctx.exec('pmem2_persist_valgrind', self.test_case, filepath)<<NEWL>>        pmemecheck_log = os.path.join(<<NEWL>>            os.getcwd(), 'pmem2_persist_valgrind', 'pmemcheck2.log')<<NEWL>>        futils.tail(pmemecheck_log, 2)<<NEWL>><<NEWL>><<NEWL>>class TEST3(PMEM2_PERSIST):<<NEWL>>    """"""persist data in a range of the memory mapped by mmap()""""""<<NEWL>>    test_case = ""test_persist_nonpmem_data"""
252	adjudicated	0	"import datetime, json, os, sys<<NEWL>>from lib.crawling import Crawling<<NEWL>>from lib.database import DB<<NEWL>>from lib.telegram import TeleGram<<NEWL>>from lib.make_data import Make_Data<<NEWL>>from lib.settings import logger, make_folder, args_check, json_check, now, photo_path<<NEWL>><<NEWL>>def run(hscode_dict, crawling, db, tele, make):<<NEWL>>    menus = ''<<NEWL>>    menus += '# ' + now.strftime('#%Y%m%d') + '\n'<<NEWL>><<NEWL>>    for title in hscode_dict:<<NEWL>>        tag = '#' + ' ' + '#' + title + ' ' + now.strftime('#%Y%m%d')    <<NEWL>>        photo_name = photo_path + str(hscode_dict[title]) + '_' + str(now.year) + str(now.month) + str(now.day) + '.png'<<NEWL>>        crawling_dict = crawling.get_search(hscode_dict[title])<<NEWL>>        df, template, month = make.data_remodel(crawling_dict, hscode_dict[title], tag, db)<<NEWL>>        make.make_photo(df, title, hscode_dict[title], photo_name, month)<<NEWL>>        tele.send_photo(photo_name, template)<<NEWL>>        db.insert_update_db(title, hscode_dict[title], crawling_dict)<<NEWL>>        menus += '#' + title + '\n'<<NEWL>>    tele.send_message(menus)<<NEWL>><<NEWL>>def main():<<NEWL>>    crawling = Crawling()<<NEWL>>    db = DB()<<NEWL>>    tele = TeleGram()<<NEWL>>    make = Make_Data()<<NEWL>><<NEWL>>    for json_file in json_list:<<NEWL>>        with open(json_path + json_file, 'r', encoding='utf-8') as f:<<NEWL>>            hscode_dict = json.load(f)<<NEWL>>        run(hscode_dict, crawling, db, tele, make)<<NEWL>>        f.close()    <<NEWL>><<NEWL>>    db.cs.close()<<NEWL>>    crawling.driver.close()<<NEWL>><<NEWL>>if __name__ == '__main__':<<NEWL>>    args = sys.argv<<NEWL>>    json_path = args_check(args)<<NEWL>>    json_list = json_check(json_path)<<NEWL>><<NEWL>>    logger(f""Main started at {now}"")<<NEWL>>    make_folder()<<NEWL>>    main()<<NEWL>>    et = datetime.datetime.now()<<NEWL>>    logger(f""Main finished at {et}"")<<NEWL>>    logger(f""Main time for task: {et-now}"")<<NEWL>>    os.system(""sudo rm -rf {photo_path}*.png"".format(photo_path=photo_path))"
343	adjudicated	4	"""""""<<NEWL>>PostGIS to GDAL conversion constant definitions<<NEWL>>""""""<<NEWL>># Lookup to convert pixel type values from GDAL to PostGIS<<NEWL>>GDAL_TO_POSTGIS = [None, 4, 6, 5, 8, 7, 10, 11, None, None, None, None]<<NEWL>><<NEWL>># Lookup to convert pixel type values from PostGIS to GDAL<<NEWL>>POSTGIS_TO_GDAL = [1, 1, 1, 3, 1, 3, 2, 5, 4, None, 6, 7, None, None]<<NEWL>><<NEWL>># Struct pack structure for raster header, the raster header has the<<NEWL>># following structure:<<NEWL>>#<<NEWL>># Endianness, PostGIS raster version, number of bands, scale, origin,<<NEWL>># skew, srid, width, and height.<<NEWL>>#<<NEWL>># Scale, origin, and skew have x and y values. PostGIS currently uses<<NEWL>># a fixed endianness (1) and there is only one version (0).<<NEWL>>POSTGIS_HEADER_STRUCTURE = 'B H H d d d d d d i H H'<<NEWL>><<NEWL>># Lookup values to convert GDAL pixel types to struct characters. This is<<NEWL>># used to pack and unpack the pixel values of PostGIS raster bands.<<NEWL>>GDAL_TO_STRUCT = [<<NEWL>>    None, 'B', 'H', 'h', 'L', 'l', 'f', 'd',<<NEWL>>    None, None, None, None,<<NEWL>>]<<NEWL>><<NEWL>># Size of the packed value in bytes for different numerical types.<<NEWL>># This is needed to cut chunks of band data out of PostGIS raster strings<<NEWL>># when decomposing them into GDALRasters.<<NEWL>># See https://docs.python.org/library/struct.html#format-characters<<NEWL>>STRUCT_SIZE = {<<NEWL>>    'b': 1,  # Signed char<<NEWL>>    'B': 1,  # Unsigned char<<NEWL>>    '?': 1,  # _Bool<<NEWL>>    'h': 2,  # Short<<NEWL>>    'H': 2,  # Unsigned short<<NEWL>>    'i': 4,  # Integer<<NEWL>>    'I': 4,  # Unsigned Integer<<NEWL>>    'l': 4,  # Long<<NEWL>>    'L': 4,  # Unsigned Long<<NEWL>>    'f': 4,  # Float<<NEWL>>    'd': 8,  # Double<<NEWL>>}<<NEWL>><<NEWL>># Pixel type specifies type of pixel values in a band. Storage flag specifies<<NEWL>># whether the band data is stored as part of the datum or is to be found on the<<NEWL>># server's filesystem. There are currently 11 supported pixel value types, so 4<<NEWL>># bits are enough to account for all. Reserve the upper 4 bits for generic<<NEWL>># flags.<<NEWL>># See https://trac.osgeo.org/postgis/wiki/WKTRaster/RFC/RFC1_V0SerialFormat#Pixeltypeandstorageflag<<NEWL>>BANDTYPE_PIXTYPE_MASK = 0x0F<<NEWL>>BANDTYPE_FLAG_HASNODATA = 1 << 6"
192	adjudicated	1	"import functools<<NEWL>>from typing import Callable, Generator, Iterable, Iterator, Optional, Tuple<<NEWL>><<NEWL>>from pip._vendor.rich.progress import (<<NEWL>>    BarColumn,<<NEWL>>    DownloadColumn,<<NEWL>>    FileSizeColumn,<<NEWL>>    Progress,<<NEWL>>    ProgressColumn,<<NEWL>>    SpinnerColumn,<<NEWL>>    TextColumn,<<NEWL>>    TimeElapsedColumn,<<NEWL>>    TimeRemainingColumn,<<NEWL>>    TransferSpeedColumn,<<NEWL>>)<<NEWL>><<NEWL>>from pip._internal.utils.logging import get_indentation<<NEWL>><<NEWL>>DownloadProgressRenderer = Callable[[Iterable[bytes]], Iterator[bytes]]<<NEWL>><<NEWL>><<NEWL>>def _rich_progress_bar(<<NEWL>>    iterable: Iterable[bytes],<<NEWL>>    *,<<NEWL>>    bar_type: str,<<NEWL>>    size: int,<<NEWL>>) -> Generator[bytes, None, None]:<<NEWL>>    assert bar_type == ""on"", ""This should only be used in the default mode.""<<NEWL>><<NEWL>>    if not size:<<NEWL>>        total = float(""inf"")<<NEWL>>        columns: Tuple[ProgressColumn, ...] = (<<NEWL>>            TextColumn(""[progress.description]{task.description}""),<<NEWL>>            SpinnerColumn(""line"", speed=1.5),<<NEWL>>            FileSizeColumn(),<<NEWL>>            TransferSpeedColumn(),<<NEWL>>            TimeElapsedColumn(),<<NEWL>>        )<<NEWL>>    else:<<NEWL>>        total = size<<NEWL>>        columns = (<<NEWL>>            TextColumn(""[progress.description]{task.description}""),<<NEWL>>            BarColumn(),<<NEWL>>            DownloadColumn(),<<NEWL>>            TransferSpeedColumn(),<<NEWL>>            TextColumn(""eta""),<<NEWL>>            TimeRemainingColumn(),<<NEWL>>        )<<NEWL>><<NEWL>>    progress = Progress(*columns, refresh_per_second=30)<<NEWL>>    task_id = progress.add_task("" "" * (get_indentation() + 2), total=total)<<NEWL>>    with progress:<<NEWL>>        for chunk in iterable:<<NEWL>>            yield chunk<<NEWL>>            progress.update(task_id, advance=len(chunk))<<NEWL>><<NEWL>><<NEWL>>def get_download_progress_renderer(<<NEWL>>    *, bar_type: str, size: Optional[int] = None<<NEWL>>) -> DownloadProgressRenderer:<<NEWL>>    """"""Get an object that can be used to render the download progress.<<NEWL>><<NEWL>>    Returns a callable, that takes an iterable to ""wrap"".<<NEWL>>    """"""<<NEWL>>    if bar_type == ""on"":<<NEWL>>        return functools.partial(_rich_progress_bar, bar_type=bar_type, size=size)<<NEWL>>    else:<<NEWL>>        return iter  # no-op, when passed an iterator"
203	adjudicated	3	"from importlib import import_module<<NEWL>><<NEWL>>from django.utils.version import get_docs_version<<NEWL>><<NEWL>><<NEWL>>def deconstructible(*args, path=None):<<NEWL>>    """"""<<NEWL>>    Class decorator that allows the decorated class to be serialized<<NEWL>>    by the migrations subsystem.<<NEWL>><<NEWL>>    The `path` kwarg specifies the import path.<<NEWL>>    """"""<<NEWL>><<NEWL>>    def decorator(klass):<<NEWL>>        def __new__(cls, *args, **kwargs):<<NEWL>>            # We capture the arguments to make returning them trivial<<NEWL>>            obj = super(klass, cls).__new__(cls)<<NEWL>>            obj._constructor_args = (args, kwargs)<<NEWL>>            return obj<<NEWL>><<NEWL>>        def deconstruct(obj):<<NEWL>>            """"""<<NEWL>>            Return a 3-tuple of class import path, positional arguments,<<NEWL>>            and keyword arguments.<<NEWL>>            """"""<<NEWL>>            # Fallback version<<NEWL>>            if path and type(obj) is klass:<<NEWL>>                module_name, _, name = path.rpartition(""."")<<NEWL>>            else:<<NEWL>>                module_name = obj.__module__<<NEWL>>                name = obj.__class__.__name__<<NEWL>>            # Make sure it's actually there and not an inner class<<NEWL>>            module = import_module(module_name)<<NEWL>>            if not hasattr(module, name):<<NEWL>>                raise ValueError(<<NEWL>>                    ""Could not find object %s in %s.\n""<<NEWL>>                    ""Please note that you cannot serialize things like inner ""<<NEWL>>                    ""classes. Please move the object into the main module ""<<NEWL>>                    ""body to use migrations.\n""<<NEWL>>                    ""For more information, see ""<<NEWL>>                    ""https://docs.djangoproject.com/en/%s/topics/migrations/""<<NEWL>>                    ""#serializing-values"" % (name, module_name, get_docs_version())<<NEWL>>                )<<NEWL>>            return (<<NEWL>>                path<<NEWL>>                if path and type(obj) is klass<<NEWL>>                else f""{obj.__class__.__module__}.{name}"",<<NEWL>>                obj._constructor_args[0],<<NEWL>>                obj._constructor_args[1],<<NEWL>>            )<<NEWL>><<NEWL>>        klass.__new__ = staticmethod(__new__)<<NEWL>>        klass.deconstruct = deconstruct<<NEWL>><<NEWL>>        return klass<<NEWL>><<NEWL>>    if not args:<<NEWL>>        return decorator<<NEWL>>    return decorator(*args)"
21	adjudicated	1	"# Levels<<NEWL>>DEBUG = 10<<NEWL>>INFO = 20<<NEWL>>WARNING = 30<<NEWL>>ERROR = 40<<NEWL>>CRITICAL = 50<<NEWL>><<NEWL>><<NEWL>>class CheckMessage:<<NEWL>><<NEWL>>    def __init__(self, level, msg, hint=None, obj=None, id=None):<<NEWL>>        assert isinstance(level, int), ""The first argument should be level.""<<NEWL>>        self.level = level<<NEWL>>        self.msg = msg<<NEWL>>        self.hint = hint<<NEWL>>        self.obj = obj<<NEWL>>        self.id = id<<NEWL>><<NEWL>>    def __eq__(self, other):<<NEWL>>        return (<<NEWL>>            isinstance(other, self.__class__) and<<NEWL>>            all(getattr(self, attr) == getattr(other, attr)<<NEWL>>                for attr in ['level', 'msg', 'hint', 'obj', 'id'])<<NEWL>>        )<<NEWL>><<NEWL>>    def __str__(self):<<NEWL>>        from django.db import models<<NEWL>><<NEWL>>        if self.obj is None:<<NEWL>>            obj = ""?""<<NEWL>>        elif isinstance(self.obj, models.base.ModelBase):<<NEWL>>            # We need to hardcode ModelBase and Field cases because its __str__<<NEWL>>            # method doesn't return ""applabel.modellabel"" and cannot be changed.<<NEWL>>            obj = self.obj._meta.label<<NEWL>>        else:<<NEWL>>            obj = str(self.obj)<<NEWL>>        id = ""(%s) "" % self.id if self.id else """"<<NEWL>>        hint = ""\n\tHINT: %s"" % self.hint if self.hint else ''<<NEWL>>        return ""%s: %s%s%s"" % (obj, id, self.msg, hint)<<NEWL>><<NEWL>>    def __repr__(self):<<NEWL>>        return ""<%s: level=%r, msg=%r, hint=%r, obj=%r, id=%r>"" % \<<NEWL>>            (self.__class__.__name__, self.level, self.msg, self.hint, self.obj, self.id)<<NEWL>><<NEWL>>    def is_serious(self, level=ERROR):<<NEWL>>        return self.level >= level<<NEWL>><<NEWL>>    def is_silenced(self):<<NEWL>>        from django.conf import settings<<NEWL>>        return self.id in settings.SILENCED_SYSTEM_CHECKS<<NEWL>><<NEWL>><<NEWL>>class Debug(CheckMessage):<<NEWL>>    def __init__(self, *args, **kwargs):<<NEWL>>        super().__init__(DEBUG, *args, **kwargs)<<NEWL>><<NEWL>><<NEWL>>class Info(CheckMessage):<<NEWL>>    def __init__(self, *args, **kwargs):<<NEWL>>        super().__init__(INFO, *args, **kwargs)<<NEWL>><<NEWL>><<NEWL>>class Warning(CheckMessage):<<NEWL>>    def __init__(self, *args, **kwargs):<<NEWL>>        super().__init__(WARNING, *args, **kwargs)<<NEWL>><<NEWL>><<NEWL>>class Error(CheckMessage):<<NEWL>>    def __init__(self, *args, **kwargs):<<NEWL>>        super().__init__(ERROR, *args, **kwargs)<<NEWL>><<NEWL>><<NEWL>>class Critical(CheckMessage):<<NEWL>>    def __init__(self, *args, **kwargs):<<NEWL>>        super().__init__(CRITICAL, *args, **kwargs)"
161	adjudicated	0	"from django.contrib.messages.views import SuccessMessageMixin<<NEWL>>from django.urls import reverse_lazy<<NEWL>>from django.views.generic import ListView<<NEWL>>from django.views.generic.edit import CreateView, UpdateView, DeleteView<<NEWL>>from .forms import FlatForm<<NEWL>>from .mixins import HousesAddMixin, SeveralInstanceCreateMixin<<NEWL>>from .models import Flat<<NEWL>>from django.utils.translation import gettext_lazy as _<<NEWL>><<NEWL>>from ..mixins import LoginRequiredMixinCustom<<NEWL>><<NEWL>><<NEWL>>class FlatCreateView(LoginRequiredMixinCustom, SeveralInstanceCreateMixin,<<NEWL>>                     SuccessMessageMixin, CreateView):<<NEWL>>    form_class = FlatForm<<NEWL>>    template_name = ""flat/create.html""<<NEWL>>    success_url = reverse_lazy('flat_list')<<NEWL>>    login_url = reverse_lazy(""user_login"")<<NEWL>>    extra_context = {<<NEWL>>        'header': _('Create flat'),<<NEWL>>        'button_title': _('Create'),<<NEWL>>    }<<NEWL>>    success_message = _('Flat created successfully')<<NEWL>><<NEWL>><<NEWL>>class FlatListView(LoginRequiredMixinCustom, HousesAddMixin, ListView):<<NEWL>>    model = Flat<<NEWL>>    template_name = ""flat/list.html""<<NEWL>>    extra_context = {<<NEWL>>        ""remove_title"": _(""remove"")<<NEWL>>    }<<NEWL>><<NEWL>><<NEWL>>class FlatUpdateView(LoginRequiredMixinCustom,<<NEWL>>                     SuccessMessageMixin, UpdateView):<<NEWL>>    model = Flat<<NEWL>>    form_class = FlatForm<<NEWL>>    template_name = ""flat/create.html""<<NEWL>>    success_url = reverse_lazy('flat_list')<<NEWL>>    extra_context = {<<NEWL>>        'header': _('Update Flat'),<<NEWL>>        'button_title': _('Update'),<<NEWL>>    }<<NEWL>>    success_message = _('Flat updated successfully')<<NEWL>><<NEWL>><<NEWL>>class FlatDeleteView(LoginRequiredMixinCustom,<<NEWL>>                     SuccessMessageMixin, DeleteView):<<NEWL>>    model = Flat<<NEWL>>    template_name = ""flat/delete.html""<<NEWL>>    success_url = reverse_lazy('flat_list')<<NEWL>>    extra_context = {<<NEWL>>        'header': _('Remove flat'),<<NEWL>>        'button_title': _('Remove '),<<NEWL>>        'message': _('Are you sure delete flat '),<<NEWL>>    }<<NEWL>>    success_message = _('Flat deleted successfully')"
70	adjudicated	4	"""""""Simple function for embedding an IPython kernel<<NEWL>>""""""<<NEWL>># -----------------------------------------------------------------------------<<NEWL>># Imports<<NEWL>># -----------------------------------------------------------------------------<<NEWL>><<NEWL>>import sys<<NEWL>><<NEWL>>from IPython.utils.frame import extract_module_locals<<NEWL>><<NEWL>>from .kernelapp import IPKernelApp<<NEWL>><<NEWL>># -----------------------------------------------------------------------------<<NEWL>># Code<<NEWL>># -----------------------------------------------------------------------------<<NEWL>><<NEWL>><<NEWL>>def embed_kernel(module=None, local_ns=None, **kwargs):<<NEWL>>    """"""Embed and start an IPython kernel in a given scope.<<NEWL>><<NEWL>>    Parameters<<NEWL>>    ----------<<NEWL>>    module : ModuleType, optional<<NEWL>>        The module to load into IPython globals (default: caller)<<NEWL>>    local_ns : dict, optional<<NEWL>>        The namespace to load into IPython user namespace (default: caller)<<NEWL>>    **kwargs : various, optional<<NEWL>>        Further keyword args are relayed to the IPKernelApp constructor,<<NEWL>>        allowing configuration of the Kernel.  Will only have an effect<<NEWL>>        on the first embed_kernel call for a given process.<<NEWL>><<NEWL>>    """"""<<NEWL>>    # get the app if it exists, or set it up if it doesn't<<NEWL>>    if IPKernelApp.initialized():<<NEWL>>        app = IPKernelApp.instance()<<NEWL>>    else:<<NEWL>>        app = IPKernelApp.instance(**kwargs)<<NEWL>>        app.initialize([])<<NEWL>>        # Undo unnecessary sys module mangling from init_sys_modules.<<NEWL>>        # This would not be necessary if we could prevent it<<NEWL>>        # in the first place by using a different InteractiveShell<<NEWL>>        # subclass, as in the regular embed case.<<NEWL>>        main = app.kernel.shell._orig_sys_modules_main_mod<<NEWL>>        if main is not None:<<NEWL>>            sys.modules[app.kernel.shell._orig_sys_modules_main_name] = main<<NEWL>><<NEWL>>    # load the calling scope if not given<<NEWL>>    (caller_module, caller_locals) = extract_module_locals(1)<<NEWL>>    if module is None:<<NEWL>>        module = caller_module<<NEWL>>    if local_ns is None:<<NEWL>>        local_ns = caller_locals<<NEWL>><<NEWL>>    app.kernel.user_module = module<<NEWL>>    app.kernel.user_ns = local_ns<<NEWL>>    app.shell.set_completer_frame()<<NEWL>>    app.start()"
130	adjudicated	4	"""""""<<NEWL>>Given a list of integers, made up of (hopefully) a small number of long runs<<NEWL>>of consecutive integers, compute a representation of the form<<NEWL>>((start1, end1), (start2, end2) ...). Then answer the question ""was x present<<NEWL>>in the original list?"" in time O(log(# runs)).<<NEWL>>""""""<<NEWL>><<NEWL>>import bisect<<NEWL>>from typing import List, Tuple<<NEWL>><<NEWL>>def intranges_from_list(list_: List[int]) -> Tuple[int, ...]:<<NEWL>>    """"""Represent a list of integers as a sequence of ranges:<<NEWL>>    ((start_0, end_0), (start_1, end_1), ...), such that the original<<NEWL>>    integers are exactly those x such that start_i <= x < end_i for some i.<<NEWL>><<NEWL>>    Ranges are encoded as single integers (start << 32 | end), not as tuples.<<NEWL>>    """"""<<NEWL>><<NEWL>>    sorted_list = sorted(list_)<<NEWL>>    ranges = []<<NEWL>>    last_write = -1<<NEWL>>    for i in range(len(sorted_list)):<<NEWL>>        if i+1 < len(sorted_list):<<NEWL>>            if sorted_list[i] == sorted_list[i+1]-1:<<NEWL>>                continue<<NEWL>>        current_range = sorted_list[last_write+1:i+1]<<NEWL>>        ranges.append(_encode_range(current_range[0], current_range[-1] + 1))<<NEWL>>        last_write = i<<NEWL>><<NEWL>>    return tuple(ranges)<<NEWL>><<NEWL>>def _encode_range(start: int, end: int) -> int:<<NEWL>>    return (start << 32) | end<<NEWL>><<NEWL>>def _decode_range(r: int) -> Tuple[int, int]:<<NEWL>>    return (r >> 32), (r & ((1 << 32) - 1))<<NEWL>><<NEWL>><<NEWL>>def intranges_contain(int_: int, ranges: Tuple[int, ...]) -> bool:<<NEWL>>    """"""Determine if `int_` falls into one of the ranges in `ranges`.""""""<<NEWL>>    tuple_ = _encode_range(int_, 0)<<NEWL>>    pos = bisect.bisect_left(ranges, tuple_)<<NEWL>>    # we could be immediately ahead of a tuple (start, end)<<NEWL>>    # with start < int_ <= end<<NEWL>>    if pos > 0:<<NEWL>>        left, right = _decode_range(ranges[pos-1])<<NEWL>>        if left <= int_ < right:<<NEWL>>            return True<<NEWL>>    # or we could be immediately behind a tuple (int_, end)<<NEWL>>    if pos < len(ranges):<<NEWL>>        left, _ = _decode_range(ranges[pos])<<NEWL>>        if left == int_:<<NEWL>>            return True<<NEWL>>    return False"
50	adjudicated	3	"# Copyright (c) Microsoft Corporation. All rights reserved.<<NEWL>># Licensed under the MIT License. See LICENSE in the project root<<NEWL>># for license information.<<NEWL>><<NEWL>>import contextlib<<NEWL>>import os<<NEWL>><<NEWL>><<NEWL>>@contextlib.contextmanager<<NEWL>>def cwd(dirname):<<NEWL>>    """"""A context manager for operating in a different directory.""""""<<NEWL>>    orig = os.getcwd()<<NEWL>>    os.chdir(dirname)<<NEWL>>    try:<<NEWL>>        yield orig<<NEWL>>    finally:<<NEWL>>        os.chdir(orig)<<NEWL>><<NEWL>><<NEWL>>def iter_all_files(root, prune_dir=None, exclude_file=None):<<NEWL>>    """"""Yield (dirname, basename, filename) for each file in the tree.<<NEWL>><<NEWL>>    This is an alternative to os.walk() that flattens out the tree and<<NEWL>>    with filtering.<<NEWL>>    """"""<<NEWL>>    pending = [root]<<NEWL>>    while pending:<<NEWL>>        dirname = pending.pop(0)<<NEWL>>        for result in _iter_files(dirname, pending, prune_dir, exclude_file):<<NEWL>>            yield result<<NEWL>><<NEWL>><<NEWL>>def iter_tree(root, prune_dir=None, exclude_file=None):<<NEWL>>    """"""Yield (dirname, files) for each directory in the tree.<<NEWL>><<NEWL>>    The list of files is actually a list of (basename, filename).<<NEWL>><<NEWL>>    This is an alternative to os.walk() with filtering.""""""<<NEWL>>    pending = [root]<<NEWL>>    while pending:<<NEWL>>        dirname = pending.pop(0)<<NEWL>>        files = []<<NEWL>>        for _, b, f in _iter_files(dirname, pending, prune_dir, exclude_file):<<NEWL>>            files.append((b, f))<<NEWL>>        yield dirname, files<<NEWL>><<NEWL>><<NEWL>>def _iter_files(dirname, subdirs, prune_dir, exclude_file):<<NEWL>>    for basename in os.listdir(dirname):<<NEWL>>        filename = os.path.join(dirname, basename)<<NEWL>>        if os.path.isdir(filename):<<NEWL>>            if prune_dir is not None and prune_dir(dirname, basename):<<NEWL>>                continue<<NEWL>>            subdirs.append(filename)<<NEWL>>        else:<<NEWL>>            # TODO: Use os.path.isfile() to narrow it down?<<NEWL>>            if exclude_file is not None and exclude_file(dirname, basename):<<NEWL>>                continue<<NEWL>>            yield dirname, basename, filename"
110	adjudicated	3	"import glob<<NEWL>>from tempfile import gettempdir<<NEWL>><<NEWL>>import os<<NEWL>><<NEWL>>import errno<<NEWL>><<NEWL>>from cloudinary.cache.storage.key_value_storage import KeyValueStorage<<NEWL>><<NEWL>><<NEWL>>class FileSystemKeyValueStorage(KeyValueStorage):<<NEWL>>    """"""File-based key-value storage""""""<<NEWL>>    _item_ext = "".cldci""<<NEWL>><<NEWL>>    def __init__(self, root_path):<<NEWL>>        """"""<<NEWL>>        Create a new Storage object.<<NEWL>><<NEWL>>        All files will be stored under the root_path location<<NEWL>><<NEWL>>        :param root_path: The base folder for all storage files<<NEWL>>        """"""<<NEWL>>        if root_path is None:<<NEWL>>            root_path = gettempdir()<<NEWL>><<NEWL>>        if not os.path.isdir(root_path):<<NEWL>>            os.makedirs(root_path)<<NEWL>><<NEWL>>        self._root_path = root_path<<NEWL>><<NEWL>>    def get(self, key):<<NEWL>>        if not self._exists(key):<<NEWL>>            return None<<NEWL>><<NEWL>>        with open(self._get_key_full_path(key), 'r') as f:<<NEWL>>            value = f.read()<<NEWL>><<NEWL>>        return value<<NEWL>><<NEWL>>    def set(self, key, value):<<NEWL>>        with open(self._get_key_full_path(key), 'w') as f:<<NEWL>>            f.write(value)<<NEWL>><<NEWL>>        return True<<NEWL>><<NEWL>>    def delete(self, key):<<NEWL>>        try:<<NEWL>>            os.remove(self._get_key_full_path(key))<<NEWL>>        except OSError as e:<<NEWL>>            if e.errno != errno.ENOENT:  # errno.ENOENT - no such file or directory<<NEWL>>                raise  # re-raise exception if a different error occurred<<NEWL>><<NEWL>>        return True<<NEWL>><<NEWL>>    def clear(self):<<NEWL>>        for cache_item_path in glob.iglob(os.path.join(self._root_path, '*' + self._item_ext)):<<NEWL>>            os.remove(cache_item_path)<<NEWL>><<NEWL>>        return True<<NEWL>><<NEWL>>    def _get_key_full_path(self, key):<<NEWL>>        """"""<<NEWL>>        Generate the file path for the key<<NEWL>><<NEWL>>        :param key: The key<<NEWL>><<NEWL>>        :return: The absolute path of the value file associated with the key<<NEWL>>        """"""<<NEWL>>        return os.path.join(self._root_path, key + self._item_ext)<<NEWL>><<NEWL>>    def _exists(self, key):<<NEWL>>        """"""<<NEWL>>        Indicate whether key exists<<NEWL>><<NEWL>>        :param key: The key<<NEWL>><<NEWL>>        :return: bool True if the file for the given key exists<<NEWL>>        """"""<<NEWL>>        return os.path.isfile(self._get_key_full_path(key))"
1	adjudicated	1	"from pandas import (<<NEWL>>    DataFrame,<<NEWL>>    Index,<<NEWL>>    Series,<<NEWL>>)<<NEWL>>import pandas._testing as tm<<NEWL>><<NEWL>><<NEWL>>class TestToFrame:<<NEWL>>    def test_to_frame_respects_name_none(self):<<NEWL>>        # GH#44212 if we explicitly pass name=None, then that should be respected,<<NEWL>>        #  not changed to 0<<NEWL>>        # GH-45448 this is first deprecated to only change in the future<<NEWL>>        ser = Series(range(3))<<NEWL>>        with tm.assert_produces_warning(FutureWarning):<<NEWL>>            result = ser.to_frame(None)<<NEWL>><<NEWL>>        # exp_index = Index([None], dtype=object)<<NEWL>>        exp_index = Index([0])<<NEWL>>        tm.assert_index_equal(result.columns, exp_index)<<NEWL>><<NEWL>>        with tm.assert_produces_warning(FutureWarning):<<NEWL>>            result = ser.rename(""foo"").to_frame(None)<<NEWL>>        exp_index = Index([""foo""], dtype=object)<<NEWL>>        tm.assert_index_equal(result.columns, exp_index)<<NEWL>><<NEWL>>    def test_to_frame(self, datetime_series):<<NEWL>>        datetime_series.name = None<<NEWL>>        rs = datetime_series.to_frame()<<NEWL>>        xp = DataFrame(datetime_series.values, index=datetime_series.index)<<NEWL>>        tm.assert_frame_equal(rs, xp)<<NEWL>><<NEWL>>        datetime_series.name = ""testname""<<NEWL>>        rs = datetime_series.to_frame()<<NEWL>>        xp = DataFrame(<<NEWL>>            {""testname"": datetime_series.values}, index=datetime_series.index<<NEWL>>        )<<NEWL>>        tm.assert_frame_equal(rs, xp)<<NEWL>><<NEWL>>        rs = datetime_series.to_frame(name=""testdifferent"")<<NEWL>>        xp = DataFrame(<<NEWL>>            {""testdifferent"": datetime_series.values}, index=datetime_series.index<<NEWL>>        )<<NEWL>>        tm.assert_frame_equal(rs, xp)<<NEWL>><<NEWL>>    def test_to_frame_expanddim(self):<<NEWL>>        # GH#9762<<NEWL>><<NEWL>>        class SubclassedSeries(Series):<<NEWL>>            @property<<NEWL>>            def _constructor_expanddim(self):<<NEWL>>                return SubclassedFrame<<NEWL>><<NEWL>>        class SubclassedFrame(DataFrame):<<NEWL>>            pass<<NEWL>><<NEWL>>        ser = SubclassedSeries([1, 2, 3], name=""X"")<<NEWL>>        result = ser.to_frame()<<NEWL>>        assert isinstance(result, SubclassedFrame)<<NEWL>>        expected = SubclassedFrame({""X"": [1, 2, 3]})<<NEWL>>        tm.assert_frame_equal(result, expected)"
390	adjudicated	0	"######################## BEGIN LICENSE BLOCK ########################<<NEWL>># The Original Code is mozilla.org code.<<NEWL>>#<<NEWL>># The Initial Developer of the Original Code is<<NEWL>># Netscape Communications Corporation.<<NEWL>># Portions created by the Initial Developer are Copyright (C) 1998<<NEWL>># the Initial Developer. All Rights Reserved.<<NEWL>>#<<NEWL>># Contributor(s):<<NEWL>>#   Mark Pilgrim - port to Python<<NEWL>>#<<NEWL>># This library is free software; you can redistribute it and/or<<NEWL>># modify it under the terms of the GNU Lesser General Public<<NEWL>># License as published by the Free Software Foundation; either<<NEWL>># version 2.1 of the License, or (at your option) any later version.<<NEWL>>#<<NEWL>># This library is distributed in the hope that it will be useful,<<NEWL>># but WITHOUT ANY WARRANTY; without even the implied warranty of<<NEWL>># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU<<NEWL>># Lesser General Public License for more details.<<NEWL>>#<<NEWL>># You should have received a copy of the GNU Lesser General Public<<NEWL>># License along with this library; if not, write to the Free Software<<NEWL>># Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA<<NEWL>># 02110-1301  USA<<NEWL>>######################### END LICENSE BLOCK #########################<<NEWL>><<NEWL>>from .chardistribution import EUCKRDistributionAnalysis<<NEWL>>from .codingstatemachine import CodingStateMachine<<NEWL>>from .mbcharsetprober import MultiByteCharSetProber<<NEWL>>from .mbcssm import EUCKR_SM_MODEL<<NEWL>><<NEWL>><<NEWL>>class EUCKRProber(MultiByteCharSetProber):<<NEWL>>    def __init__(self) -> None:<<NEWL>>        super().__init__()<<NEWL>>        self.coding_sm = CodingStateMachine(EUCKR_SM_MODEL)<<NEWL>>        self.distribution_analyzer = EUCKRDistributionAnalysis()<<NEWL>>        self.reset()<<NEWL>><<NEWL>>    @property<<NEWL>>    def charset_name(self) -> str:<<NEWL>>        return ""EUC-KR""<<NEWL>><<NEWL>>    @property<<NEWL>>    def language(self) -> str:<<NEWL>>        return ""Korean"""
141	adjudicated	3	"import typing as t<<NEWL>><<NEWL>>try:<<NEWL>>    from blinker import Namespace<<NEWL>><<NEWL>>    signals_available = True<<NEWL>>except ImportError:<<NEWL>>    signals_available = False<<NEWL>><<NEWL>>    class Namespace:  # type: ignore<<NEWL>>        def signal(self, name: str, doc: t.Optional[str] = None) -> ""_FakeSignal"":<<NEWL>>            return _FakeSignal(name, doc)<<NEWL>><<NEWL>>    class _FakeSignal:<<NEWL>>        """"""If blinker is unavailable, create a fake class with the same<<NEWL>>        interface that allows sending of signals but will fail with an<<NEWL>>        error on anything else.  Instead of doing anything on send, it<<NEWL>>        will just ignore the arguments and do nothing instead.<<NEWL>>        """"""<<NEWL>><<NEWL>>        def __init__(self, name: str, doc: t.Optional[str] = None) -> None:<<NEWL>>            self.name = name<<NEWL>>            self.__doc__ = doc<<NEWL>><<NEWL>>        def send(self, *args: t.Any, **kwargs: t.Any) -> t.Any:<<NEWL>>            pass<<NEWL>><<NEWL>>        def _fail(self, *args: t.Any, **kwargs: t.Any) -> t.Any:<<NEWL>>            raise RuntimeError(<<NEWL>>                ""Signalling support is unavailable because the blinker""<<NEWL>>                "" library is not installed.""<<NEWL>>            ) from None<<NEWL>><<NEWL>>        connect = connect_via = connected_to = temporarily_connected_to = _fail<<NEWL>>        disconnect = _fail<<NEWL>>        has_receivers_for = receivers_for = _fail<<NEWL>>        del _fail<<NEWL>><<NEWL>><<NEWL>># The namespace for code signals.  If you are not Flask code, do<<NEWL>># not put signals in here.  Create your own namespace instead.<<NEWL>>_signals = Namespace()<<NEWL>><<NEWL>><<NEWL>># Core signals.  For usage examples grep the source code or consult<<NEWL>># the API documentation in docs/api.rst as well as docs/signals.rst<<NEWL>>template_rendered = _signals.signal(""template-rendered"")<<NEWL>>before_render_template = _signals.signal(""before-render-template"")<<NEWL>>request_started = _signals.signal(""request-started"")<<NEWL>>request_finished = _signals.signal(""request-finished"")<<NEWL>>request_tearing_down = _signals.signal(""request-tearing-down"")<<NEWL>>got_request_exception = _signals.signal(""got-request-exception"")<<NEWL>>appcontext_tearing_down = _signals.signal(""appcontext-tearing-down"")<<NEWL>>appcontext_pushed = _signals.signal(""appcontext-pushed"")<<NEWL>>appcontext_popped = _signals.signal(""appcontext-popped"")<<NEWL>>message_flashed = _signals.signal(""message-flashed"")"
363	adjudicated	0	"import esphome.codegen as cg<<NEWL>>import esphome.config_validation as cv<<NEWL>>from esphome.components import switch<<NEWL>>from esphome.const import ICON_POWER<<NEWL>>from .. import CONF_PIPSOLAR_ID, PIPSOLAR_COMPONENT_SCHEMA, pipsolar_ns<<NEWL>><<NEWL>>DEPENDENCIES = [""uart""]<<NEWL>><<NEWL>>CONF_OUTPUT_SOURCE_PRIORITY_UTILITY = ""output_source_priority_utility""<<NEWL>>CONF_OUTPUT_SOURCE_PRIORITY_SOLAR = ""output_source_priority_solar""<<NEWL>>CONF_OUTPUT_SOURCE_PRIORITY_BATTERY = ""output_source_priority_battery""<<NEWL>>CONF_INPUT_VOLTAGE_RANGE = ""input_voltage_range""<<NEWL>>CONF_PV_OK_CONDITION_FOR_PARALLEL = ""pv_ok_condition_for_parallel""<<NEWL>>CONF_PV_POWER_BALANCE = ""pv_power_balance""<<NEWL>><<NEWL>>TYPES = {<<NEWL>>    CONF_OUTPUT_SOURCE_PRIORITY_UTILITY: (""POP00"", None),<<NEWL>>    CONF_OUTPUT_SOURCE_PRIORITY_SOLAR: (""POP01"", None),<<NEWL>>    CONF_OUTPUT_SOURCE_PRIORITY_BATTERY: (""POP02"", None),<<NEWL>>    CONF_INPUT_VOLTAGE_RANGE: (""PGR01"", ""PGR00""),<<NEWL>>    CONF_PV_OK_CONDITION_FOR_PARALLEL: (""PPVOKC1"", ""PPVOKC0""),<<NEWL>>    CONF_PV_POWER_BALANCE: (""PSPB1"", ""PSPB0""),<<NEWL>>}<<NEWL>><<NEWL>>PipsolarSwitch = pipsolar_ns.class_(""PipsolarSwitch"", switch.Switch, cg.Component)<<NEWL>><<NEWL>>PIPSWITCH_SCHEMA = switch.switch_schema(<<NEWL>>    PipsolarSwitch, icon=ICON_POWER, block_inverted=True<<NEWL>>).extend(cv.COMPONENT_SCHEMA)<<NEWL>><<NEWL>>CONFIG_SCHEMA = PIPSOLAR_COMPONENT_SCHEMA.extend(<<NEWL>>    {cv.Optional(type): PIPSWITCH_SCHEMA for type in TYPES}<<NEWL>>)<<NEWL>><<NEWL>><<NEWL>>async def to_code(config):<<NEWL>>    paren = await cg.get_variable(config[CONF_PIPSOLAR_ID])<<NEWL>><<NEWL>>    for type, (on, off) in TYPES.items():<<NEWL>>        if type in config:<<NEWL>>            conf = config[type]<<NEWL>>            var = await switch.new_switch(conf)<<NEWL>>            await cg.register_component(var, conf)<<NEWL>>            cg.add(getattr(paren, f""set_{type}_switch"")(var))<<NEWL>>            cg.add(var.set_parent(paren))<<NEWL>>            cg.add(var.set_on_command(on))<<NEWL>>            if off is not None:<<NEWL>>                cg.add(var.set_off_command(off))"
223	adjudicated	1	"# Copyright 2016 Google LLC<<NEWL>>#<<NEWL>># Licensed under the Apache License, Version 2.0 (the ""License"");<<NEWL>># you may not use this file except in compliance with the License.<<NEWL>># You may obtain a copy of the License at<<NEWL>>#<<NEWL>>#     http://www.apache.org/licenses/LICENSE-2.0<<NEWL>>#<<NEWL>># Unless required by applicable law or agreed to in writing, software<<NEWL>># distributed under the License is distributed on an ""AS IS"" BASIS,<<NEWL>># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<<NEWL>># See the License for the specific language governing permissions and<<NEWL>># limitations under the License.<<NEWL>><<NEWL>>import os<<NEWL>>import uuid<<NEWL>><<NEWL>>import pytest<<NEWL>><<NEWL>>from product_management import create_product, delete_product<<NEWL>>from reference_image_management import (<<NEWL>>    create_reference_image, delete_reference_image, list_reference_images)<<NEWL>><<NEWL>><<NEWL>>PROJECT_ID = os.getenv('GOOGLE_CLOUD_PROJECT')<<NEWL>>LOCATION = 'us-west1'<<NEWL>><<NEWL>>PRODUCT_DISPLAY_NAME = 'fake_product_display_name_for_testing'<<NEWL>>PRODUCT_CATEGORY = 'homegoods'<<NEWL>>PRODUCT_ID = 'test_{}'.format(uuid.uuid4())<<NEWL>><<NEWL>>REFERENCE_IMAGE_ID = 'fake_reference_image_id_for_testing'<<NEWL>>GCS_URI = 'gs://cloud-samples-data/vision/product_search/shoes_1.jpg'<<NEWL>><<NEWL>><<NEWL>>@pytest.fixture(scope=""function"", autouse=True)<<NEWL>>def setup_teardown():<<NEWL>>    # set up<<NEWL>>    create_product(<<NEWL>>        PROJECT_ID, LOCATION, PRODUCT_ID,<<NEWL>>        PRODUCT_DISPLAY_NAME, PRODUCT_CATEGORY)<<NEWL>><<NEWL>>    yield None<<NEWL>><<NEWL>>    # tear down<<NEWL>>    delete_product(PROJECT_ID, LOCATION, PRODUCT_ID)<<NEWL>><<NEWL>><<NEWL>>def test_create_reference_image(capsys):<<NEWL>>    create_reference_image(<<NEWL>>        PROJECT_ID, LOCATION, PRODUCT_ID, REFERENCE_IMAGE_ID,<<NEWL>>        GCS_URI)<<NEWL>>    list_reference_images(PROJECT_ID, LOCATION, PRODUCT_ID)<<NEWL>>    out, _ = capsys.readouterr()<<NEWL>>    assert REFERENCE_IMAGE_ID in out<<NEWL>><<NEWL>><<NEWL>>def test_delete_reference_image(capsys):<<NEWL>>    create_reference_image(<<NEWL>>        PROJECT_ID, LOCATION, PRODUCT_ID, REFERENCE_IMAGE_ID,<<NEWL>>        GCS_URI)<<NEWL>>    list_reference_images(PROJECT_ID, LOCATION, PRODUCT_ID)<<NEWL>>    out, _ = capsys.readouterr()<<NEWL>>    assert REFERENCE_IMAGE_ID in out<<NEWL>><<NEWL>>    delete_reference_image(<<NEWL>>        PROJECT_ID, LOCATION, PRODUCT_ID, REFERENCE_IMAGE_ID)<<NEWL>>    list_reference_images(PROJECT_ID, LOCATION, PRODUCT_ID)<<NEWL>>    out, _ = capsys.readouterr()<<NEWL>>    assert REFERENCE_IMAGE_ID not in out"
332	adjudicated	4	"from __future__ import annotations<<NEWL>><<NEWL>>import numpy as np<<NEWL>><<NEWL>>from pandas._typing import NumpyIndexT<<NEWL>><<NEWL>>from pandas.core.dtypes.common import is_list_like<<NEWL>><<NEWL>><<NEWL>>def cartesian_product(X) -> list[np.ndarray]:<<NEWL>>    """"""<<NEWL>>    Numpy version of itertools.product.<<NEWL>>    Sometimes faster (for large inputs)...<<NEWL>><<NEWL>>    Parameters<<NEWL>>    ----------<<NEWL>>    X : list-like of list-likes<<NEWL>><<NEWL>>    Returns<<NEWL>>    -------<<NEWL>>    product : list of ndarrays<<NEWL>><<NEWL>>    Examples<<NEWL>>    --------<<NEWL>>    >>> cartesian_product([list('ABC'), [1, 2]])<<NEWL>>    [array(['A', 'A', 'B', 'B', 'C', 'C'], dtype='<U1'), array([1, 2, 1, 2, 1, 2])]<<NEWL>><<NEWL>>    See Also<<NEWL>>    --------<<NEWL>>    itertools.product : Cartesian product of input iterables.  Equivalent to<<NEWL>>        nested for-loops.<<NEWL>>    """"""<<NEWL>>    msg = ""Input must be a list-like of list-likes""<<NEWL>>    if not is_list_like(X):<<NEWL>>        raise TypeError(msg)<<NEWL>>    for x in X:<<NEWL>>        if not is_list_like(x):<<NEWL>>            raise TypeError(msg)<<NEWL>><<NEWL>>    if len(X) == 0:<<NEWL>>        return []<<NEWL>><<NEWL>>    lenX = np.fromiter((len(x) for x in X), dtype=np.intp)<<NEWL>>    cumprodX = np.cumproduct(lenX)<<NEWL>><<NEWL>>    if np.any(cumprodX < 0):<<NEWL>>        raise ValueError(""Product space too large to allocate arrays!"")<<NEWL>><<NEWL>>    a = np.roll(cumprodX, 1)<<NEWL>>    a[0] = 1<<NEWL>><<NEWL>>    if cumprodX[-1] != 0:<<NEWL>>        b = cumprodX[-1] / cumprodX<<NEWL>>    else:<<NEWL>>        # if any factor is empty, the cartesian product is empty<<NEWL>>        b = np.zeros_like(cumprodX)<<NEWL>><<NEWL>>    # error: Argument of type ""int_"" cannot be assigned to parameter ""num"" of<<NEWL>>    # type ""int"" in function ""tile_compat""<<NEWL>>    return [<<NEWL>>        tile_compat(<<NEWL>>            np.repeat(x, b[i]),<<NEWL>>            np.product(a[i]),  # pyright: ignore[reportGeneralTypeIssues]<<NEWL>>        )<<NEWL>>        for i, x in enumerate(X)<<NEWL>>    ]<<NEWL>><<NEWL>><<NEWL>>def tile_compat(arr: NumpyIndexT, num: int) -> NumpyIndexT:<<NEWL>>    """"""<<NEWL>>    Index compat for np.tile.<<NEWL>><<NEWL>>    Notes<<NEWL>>    -----<<NEWL>>    Does not support multi-dimensional `num`.<<NEWL>>    """"""<<NEWL>>    if isinstance(arr, np.ndarray):<<NEWL>>        return np.tile(arr, num)<<NEWL>><<NEWL>>    # Otherwise we have an Index<<NEWL>>    taker = np.tile(np.arange(len(arr)), num)<<NEWL>>    return arr.take(taker)"
272	adjudicated	3	"#!/usr/bin/env python<<NEWL>>#<<NEWL>># Copyright 2020 Google LLC<<NEWL>>#<<NEWL>># Licensed under the Apache License, Version 2.0 (the ""License"");<<NEWL>># you may not use this file except in compliance with the License.<<NEWL>># You may obtain a copy of the License at<<NEWL>>#<<NEWL>>#     https://www.apache.org/licenses/LICENSE-2.0<<NEWL>>#<<NEWL>># Unless required by applicable law or agreed to in writing, software<<NEWL>># distributed under the License is distributed on an ""AS IS"" BASIS,<<NEWL>># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<<NEWL>># See the License for the specific language governing permissions and<<NEWL>># limitations under the License.<<NEWL>>""""""Demo for receiving notifications.""""""<<NEWL>><<NEWL>><<NEWL>>def receive_notifications(project_id, subscription_name):<<NEWL>>    # [START securitycenter_receive_notifications]<<NEWL>>    # Requires https://cloud.google.com/pubsub/docs/quickstart-client-libraries#pubsub-client-libraries-python<<NEWL>>    import concurrent<<NEWL>><<NEWL>>    from google.cloud import pubsub_v1<<NEWL>>    from google.cloud.securitycenter_v1 import NotificationMessage<<NEWL>><<NEWL>>    # TODO: project_id = ""your-project-id""<<NEWL>>    # TODO: subscription_name = ""your-subscription-name""<<NEWL>><<NEWL>>    def callback(message):<<NEWL>><<NEWL>>        # Print the data received for debugging purpose if needed<<NEWL>>        print(f""Received message: {message.data}"")<<NEWL>><<NEWL>>        notification_msg = NotificationMessage.from_json(message.data)<<NEWL>><<NEWL>>        print(<<NEWL>>            ""Notification config name: {}"".format(<<NEWL>>                notification_msg.notification_config_name<<NEWL>>            )<<NEWL>>        )<<NEWL>>        print(""Finding: {}"".format(notification_msg.finding))<<NEWL>><<NEWL>>        # Ack the message to prevent it from being pulled again<<NEWL>>        message.ack()<<NEWL>><<NEWL>>    subscriber = pubsub_v1.SubscriberClient()<<NEWL>>    subscription_path = subscriber.subscription_path(project_id, subscription_name)<<NEWL>><<NEWL>>    streaming_pull_future = subscriber.subscribe(subscription_path, callback=callback)<<NEWL>><<NEWL>>    print(""Listening for messages on {}...\n"".format(subscription_path))<<NEWL>>    try:<<NEWL>>        streaming_pull_future.result(timeout=1)  # Block for 1 second<<NEWL>>    except concurrent.futures.TimeoutError:<<NEWL>>        streaming_pull_future.cancel()<<NEWL>>    # [END securitycenter_receive_notifications]<<NEWL>>    return True"
175	adjudicated	1	"""""""<<NEWL>>Tests that work on both the Python and C engines but do not have a<<NEWL>>specific classification into the other test modules.<<NEWL>>""""""<<NEWL>>import csv<<NEWL>>from io import StringIO<<NEWL>><<NEWL>>import pytest<<NEWL>><<NEWL>>from pandas import DataFrame<<NEWL>>import pandas._testing as tm<<NEWL>><<NEWL>>from pandas.io.parsers import TextParser<<NEWL>><<NEWL>>xfail_pyarrow = pytest.mark.usefixtures(""pyarrow_xfail"")<<NEWL>><<NEWL>><<NEWL>>@xfail_pyarrow<<NEWL>>def test_read_data_list(all_parsers):<<NEWL>>    parser = all_parsers<<NEWL>>    kwargs = {""index_col"": 0}<<NEWL>>    data = ""A,B,C\nfoo,1,2,3\nbar,4,5,6""<<NEWL>><<NEWL>>    data_list = [[""A"", ""B"", ""C""], [""foo"", ""1"", ""2"", ""3""], [""bar"", ""4"", ""5"", ""6""]]<<NEWL>>    expected = parser.read_csv(StringIO(data), **kwargs)<<NEWL>><<NEWL>>    with TextParser(data_list, chunksize=2, **kwargs) as parser:<<NEWL>>        result = parser.read()<<NEWL>><<NEWL>>    tm.assert_frame_equal(result, expected)<<NEWL>><<NEWL>><<NEWL>>def test_reader_list(all_parsers):<<NEWL>>    data = """"""index,A,B,C,D<<NEWL>>foo,2,3,4,5<<NEWL>>bar,7,8,9,10<<NEWL>>baz,12,13,14,15<<NEWL>>qux,12,13,14,15<<NEWL>>foo2,12,13,14,15<<NEWL>>bar2,12,13,14,15<<NEWL>>""""""<<NEWL>>    parser = all_parsers<<NEWL>>    kwargs = {""index_col"": 0}<<NEWL>><<NEWL>>    lines = list(csv.reader(StringIO(data)))<<NEWL>>    with TextParser(lines, chunksize=2, **kwargs) as reader:<<NEWL>>        chunks = list(reader)<<NEWL>><<NEWL>>    expected = parser.read_csv(StringIO(data), **kwargs)<<NEWL>><<NEWL>>    tm.assert_frame_equal(chunks[0], expected[:2])<<NEWL>>    tm.assert_frame_equal(chunks[1], expected[2:4])<<NEWL>>    tm.assert_frame_equal(chunks[2], expected[4:])<<NEWL>><<NEWL>><<NEWL>>def test_reader_list_skiprows(all_parsers):<<NEWL>>    data = """"""index,A,B,C,D<<NEWL>>foo,2,3,4,5<<NEWL>>bar,7,8,9,10<<NEWL>>baz,12,13,14,15<<NEWL>>qux,12,13,14,15<<NEWL>>foo2,12,13,14,15<<NEWL>>bar2,12,13,14,15<<NEWL>>""""""<<NEWL>>    parser = all_parsers<<NEWL>>    kwargs = {""index_col"": 0}<<NEWL>><<NEWL>>    lines = list(csv.reader(StringIO(data)))<<NEWL>>    with TextParser(lines, chunksize=2, skiprows=[1], **kwargs) as reader:<<NEWL>>        chunks = list(reader)<<NEWL>><<NEWL>>    expected = parser.read_csv(StringIO(data), **kwargs)<<NEWL>><<NEWL>>    tm.assert_frame_equal(chunks[0], expected[1:3])<<NEWL>><<NEWL>><<NEWL>>def test_read_csv_parse_simple_list(all_parsers):<<NEWL>>    parser = all_parsers<<NEWL>>    data = """"""foo<<NEWL>>bar baz<<NEWL>>qux foo<<NEWL>>foo<<NEWL>>bar""""""<<NEWL>><<NEWL>>    result = parser.read_csv(StringIO(data), header=None)<<NEWL>>    expected = DataFrame([""foo"", ""bar baz"", ""qux foo"", ""foo"", ""bar""])<<NEWL>>    tm.assert_frame_equal(result, expected)"
35	adjudicated	2	"import _plotly_utils.basevalidators<<NEWL>><<NEWL>><<NEWL>>class HoverlabelValidator(_plotly_utils.basevalidators.CompoundValidator):<<NEWL>>    def __init__(self, plotly_name=""hoverlabel"", parent_name=""cone"", **kwargs):<<NEWL>>        super(HoverlabelValidator, self).__init__(<<NEWL>>            plotly_name=plotly_name,<<NEWL>>            parent_name=parent_name,<<NEWL>>            data_class_str=kwargs.pop(""data_class_str"", ""Hoverlabel""),<<NEWL>>            data_docs=kwargs.pop(<<NEWL>>                ""data_docs"",<<NEWL>>                """"""<<NEWL>>            align<<NEWL>>                Sets the horizontal alignment of the text<<NEWL>>                content within hover label box. Has an effect<<NEWL>>                only if the hover label text spans more two or<<NEWL>>                more lines<<NEWL>>            alignsrc<<NEWL>>                Sets the source reference on Chart Studio Cloud<<NEWL>>                for `align`.<<NEWL>>            bgcolor<<NEWL>>                Sets the background color of the hover labels<<NEWL>>                for this trace<<NEWL>>            bgcolorsrc<<NEWL>>                Sets the source reference on Chart Studio Cloud<<NEWL>>                for `bgcolor`.<<NEWL>>            bordercolor<<NEWL>>                Sets the border color of the hover labels for<<NEWL>>                this trace.<<NEWL>>            bordercolorsrc<<NEWL>>                Sets the source reference on Chart Studio Cloud<<NEWL>>                for `bordercolor`.<<NEWL>>            font<<NEWL>>                Sets the font used in hover labels.<<NEWL>>            namelength<<NEWL>>                Sets the default length (in number of<<NEWL>>                characters) of the trace name in the hover<<NEWL>>                labels for all traces. -1 shows the whole name<<NEWL>>                regardless of length. 0-3 shows the first 0-3<<NEWL>>                characters, and an integer >3 will show the<<NEWL>>                whole name if it is less than that many<<NEWL>>                characters, but if it is longer, will truncate<<NEWL>>                to `namelength - 3` characters and add an<<NEWL>>                ellipsis.<<NEWL>>            namelengthsrc<<NEWL>>                Sets the source reference on Chart Studio Cloud<<NEWL>>                for `namelength`.<<NEWL>>"""""",<<NEWL>>            ),<<NEWL>>            **kwargs,<<NEWL>>        )"
124	adjudicated	2	"import _plotly_utils.basevalidators<<NEWL>><<NEWL>><<NEWL>>class CumulativeValidator(_plotly_utils.basevalidators.CompoundValidator):<<NEWL>>    def __init__(self, plotly_name=""cumulative"", parent_name=""histogram"", **kwargs):<<NEWL>>        super(CumulativeValidator, self).__init__(<<NEWL>>            plotly_name=plotly_name,<<NEWL>>            parent_name=parent_name,<<NEWL>>            data_class_str=kwargs.pop(""data_class_str"", ""Cumulative""),<<NEWL>>            data_docs=kwargs.pop(<<NEWL>>                ""data_docs"",<<NEWL>>                """"""<<NEWL>>            currentbin<<NEWL>>                Only applies if cumulative is enabled. Sets<<NEWL>>                whether the current bin is included, excluded,<<NEWL>>                or has half of its value included in the<<NEWL>>                current cumulative value. ""include"" is the<<NEWL>>                default for compatibility with various other<<NEWL>>                tools, however it introduces a half-bin bias to<<NEWL>>                the results. ""exclude"" makes the opposite half-<<NEWL>>                bin bias, and ""half"" removes it.<<NEWL>>            direction<<NEWL>>                Only applies if cumulative is enabled. If<<NEWL>>                ""increasing"" (default) we sum all prior bins,<<NEWL>>                so the result increases from left to right. If<<NEWL>>                ""decreasing"" we sum later bins so the result<<NEWL>>                decreases from left to right.<<NEWL>>            enabled<<NEWL>>                If true, display the cumulative distribution by<<NEWL>>                summing the binned values. Use the `direction`<<NEWL>>                and `centralbin` attributes to tune the<<NEWL>>                accumulation method. Note: in this mode, the<<NEWL>>                ""density"" `histnorm` settings behave the same<<NEWL>>                as their equivalents without ""density"": """" and<<NEWL>>                ""density"" both rise to the number of data<<NEWL>>                points, and ""probability"" and *probability<<NEWL>>                density* both rise to the number of sample<<NEWL>>                points.<<NEWL>>"""""",<<NEWL>>            ),<<NEWL>>            **kwargs,<<NEWL>>        )"
64	adjudicated	0	"import unittest<<NEWL>><<NEWL>>from Cython import StringIOTree as stringtree<<NEWL>><<NEWL>>code = """"""<<NEWL>>cdef int spam                   # line 1<<NEWL>><<NEWL>>cdef ham():<<NEWL>>    a = 1<<NEWL>>    b = 2<<NEWL>>    c = 3<<NEWL>>    d = 4<<NEWL>><<NEWL>>def eggs():<<NEWL>>    pass<<NEWL>><<NEWL>>cpdef bacon():<<NEWL>>    print spam<<NEWL>>    print 'scotch'<<NEWL>>    print 'tea?'<<NEWL>>    print 'or coffee?'          # line 16<<NEWL>>""""""<<NEWL>><<NEWL>>linemap = dict(enumerate(code.splitlines()))<<NEWL>><<NEWL>>class TestStringIOTree(unittest.TestCase):<<NEWL>><<NEWL>>    def setUp(self):<<NEWL>>        self.tree = stringtree.StringIOTree()<<NEWL>><<NEWL>>    def test_markers(self):<<NEWL>>        assert not self.tree.allmarkers()<<NEWL>><<NEWL>>    def test_insertion(self):<<NEWL>>        self.write_lines((1, 2, 3))<<NEWL>>        line_4_to_6_insertion_point = self.tree.insertion_point()<<NEWL>>        self.write_lines((7, 8))<<NEWL>>        line_9_to_13_insertion_point = self.tree.insertion_point()<<NEWL>>        self.write_lines((14, 15, 16))<<NEWL>><<NEWL>>        line_4_insertion_point = line_4_to_6_insertion_point.insertion_point()<<NEWL>>        self.write_lines((5, 6), tree=line_4_to_6_insertion_point)<<NEWL>><<NEWL>>        line_9_to_12_insertion_point = (<<NEWL>>            line_9_to_13_insertion_point.insertion_point())<<NEWL>>        self.write_line(13, tree=line_9_to_13_insertion_point)<<NEWL>><<NEWL>>        self.write_line(4, tree=line_4_insertion_point)<<NEWL>>        self.write_line(9, tree=line_9_to_12_insertion_point)<<NEWL>>        line_10_insertion_point = line_9_to_12_insertion_point.insertion_point()<<NEWL>>        self.write_line(11, tree=line_9_to_12_insertion_point)<<NEWL>>        self.write_line(10, tree=line_10_insertion_point)<<NEWL>>        self.write_line(12, tree=line_9_to_12_insertion_point)<<NEWL>><<NEWL>>        self.assertEqual(self.tree.allmarkers(), list(range(1, 17)))<<NEWL>>        self.assertEqual(code.strip(), self.tree.getvalue().strip())<<NEWL>><<NEWL>><<NEWL>>    def write_lines(self, linenos, tree=None):<<NEWL>>        for lineno in linenos:<<NEWL>>            self.write_line(lineno, tree=tree)<<NEWL>><<NEWL>>    def write_line(self, lineno, tree=None):<<NEWL>>        if tree is None:<<NEWL>>            tree = self.tree<<NEWL>>        tree.markers.append(lineno)<<NEWL>>        tree.write(linemap[lineno] + '\n')"
246	adjudicated	2	"# Copyright 2020 Google LLC<<NEWL>>#<<NEWL>># Licensed under the Apache License, Version 2.0 (the ""License"");<<NEWL>># you may not use this file except in compliance with the License.<<NEWL>># You may obtain a copy of the License at<<NEWL>>#<<NEWL>>#     https://www.apache.org/licenses/LICENSE-2.0<<NEWL>>#<<NEWL>># Unless required by applicable law or agreed to in writing, software<<NEWL>># distributed under the License is distributed on an ""AS IS"" BASIS,<<NEWL>># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<<NEWL>># See the License for the specific language governing permissions and<<NEWL>># limitations under the License.<<NEWL>><<NEWL>># [START job_search_autocomplete_job_title]<<NEWL>><<NEWL>>from google.cloud import talent_v4beta1<<NEWL>>import six<<NEWL>><<NEWL>><<NEWL>>def complete_query(project_id, tenant_id, query):<<NEWL>>    """"""Complete job title given partial text (autocomplete)""""""<<NEWL>><<NEWL>>    client = talent_v4beta1.CompletionClient()<<NEWL>><<NEWL>>    # project_id = 'Your Google Cloud Project ID'<<NEWL>>    # tenant_id = 'Your Tenant ID (using tenancy is optional)'<<NEWL>>    # query = '[partially typed job title]'<<NEWL>><<NEWL>>    if isinstance(project_id, six.binary_type):<<NEWL>>        project_id = project_id.decode(""utf-8"")<<NEWL>>    if isinstance(tenant_id, six.binary_type):<<NEWL>>        tenant_id = tenant_id.decode(""utf-8"")<<NEWL>>    if isinstance(query, six.binary_type):<<NEWL>>        query = query.decode(""utf-8"")<<NEWL>><<NEWL>>    parent = f""projects/{project_id}/tenants/{tenant_id}""<<NEWL>><<NEWL>>    request = talent_v4beta1.CompleteQueryRequest(<<NEWL>>        parent=parent,<<NEWL>>        query=query,<<NEWL>>        page_size=5,  # limit for number of results<<NEWL>>        language_codes=[""en-US""],  # language code<<NEWL>>    )<<NEWL>>    response = client.complete_query(request=request)<<NEWL>>    for result in response.completion_results:<<NEWL>>        print(f""Suggested title: {result.suggestion}"")<<NEWL>>        # Suggestion type is JOB_TITLE or COMPANY_TITLE<<NEWL>>        print(<<NEWL>>            f""Suggestion type: {talent_v4beta1.CompleteQueryRequest.CompletionType(result.type_).name}""<<NEWL>>        )<<NEWL>><<NEWL>><<NEWL>># [END job_search_autocomplete_job_title]"
97	adjudicated	0	"import sqlite3<<NEWL>>from flask import Blueprint, render_template, redirect, request, g, session, make_response, flash<<NEWL>>import libuser<<NEWL>>import libsession<<NEWL>>import libmfa<<NEWL>>import pyotp<<NEWL>>import qrcode<<NEWL>>import base64<<NEWL>>from io import BytesIO<<NEWL>><<NEWL>><<NEWL>>mod_mfa = Blueprint('mod_mfa', __name__, template_folder='templates')<<NEWL>><<NEWL>><<NEWL>>@mod_mfa.route('/', methods=['GET'])<<NEWL>>def do_mfa_view():<<NEWL>><<NEWL>>    if 'username' not in g.session:<<NEWL>>        return redirect('/user/login')<<NEWL>><<NEWL>>    if libmfa.mfa_is_enabled(g.session['username']):<<NEWL>>        return render_template('mfa.disable.html')<<NEWL>>    else:<<NEWL>>        libmfa.mfa_reset_secret(g.session['username'])<<NEWL>>        secret = libmfa.mfa_get_secret(g.session['username'])<<NEWL>>        secret_url = pyotp.totp.TOTP(secret).provisioning_uri(g.session['username'], issuer_name=""Vulpy"")<<NEWL>>        img = qrcode.make(secret_url)<<NEWL>><<NEWL>>        buffered = BytesIO()<<NEWL>>        img.save(buffered, format=""PNG"")<<NEWL>>        img_str = base64.b64encode(buffered.getvalue()).decode()<<NEWL>><<NEWL>>        return render_template('mfa.enable.html', secret_url=secret_url, img_str=img_str)<<NEWL>><<NEWL>><<NEWL>>@mod_mfa.route('/', methods=['POST'])<<NEWL>>def do_mfa_enable():<<NEWL>><<NEWL>>    if 'username' not in g.session:<<NEWL>>        return redirect('/user/login')<<NEWL>><<NEWL>>    secret = libmfa.mfa_get_secret(g.session['username'])<<NEWL>><<NEWL>>    otp = request.form.get('otp')<<NEWL>><<NEWL>>    totp = pyotp.TOTP(secret)<<NEWL>><<NEWL>>    if totp.verify(otp):<<NEWL>>        libmfa.mfa_enable(g.session['username'])<<NEWL>>        return redirect('/mfa/')<<NEWL>>    else:<<NEWL>>        flash(""The OTP was incorrect"")<<NEWL>>        return redirect('/mfa/')<<NEWL>><<NEWL>>    return render_template('mfa.enable.html')<<NEWL>><<NEWL>><<NEWL>>@mod_mfa.route('/disable', methods=['GET'])<<NEWL>>def do_mfa_disable():<<NEWL>><<NEWL>>    if 'username' not in g.session:<<NEWL>>        return redirect('/user/login')<<NEWL>><<NEWL>>    if 'referer' not in request.headers or request.headers['referer'] != 'vulpy.com':<<NEWL>>        return redirect('/user/login')<<NEWL>><<NEWL>>    libmfa.mfa_disable(g.session['username'])<<NEWL>>    return redirect('/mfa/')<<NEWL>>"
306	adjudicated	2	"from . import engines<<NEWL>>from .exceptions import TemplateDoesNotExist<<NEWL>><<NEWL>><<NEWL>>def get_template(template_name, using=None):<<NEWL>>    """"""<<NEWL>>    Load and return a template for the given name.<<NEWL>><<NEWL>>    Raise TemplateDoesNotExist if no such template exists.<<NEWL>>    """"""<<NEWL>>    chain = []<<NEWL>>    engines = _engine_list(using)<<NEWL>>    for engine in engines:<<NEWL>>        try:<<NEWL>>            return engine.get_template(template_name)<<NEWL>>        except TemplateDoesNotExist as e:<<NEWL>>            chain.append(e)<<NEWL>><<NEWL>>    raise TemplateDoesNotExist(template_name, chain=chain)<<NEWL>><<NEWL>><<NEWL>>def select_template(template_name_list, using=None):<<NEWL>>    """"""<<NEWL>>    Load and return a template for one of the given names.<<NEWL>><<NEWL>>    Try names in order and return the first template found.<<NEWL>><<NEWL>>    Raise TemplateDoesNotExist if no such template exists.<<NEWL>>    """"""<<NEWL>>    if isinstance(template_name_list, str):<<NEWL>>        raise TypeError(<<NEWL>>            ""select_template() takes an iterable of template names but got a ""<<NEWL>>            ""string: %r. Use get_template() if you want to load a single ""<<NEWL>>            ""template by name."" % template_name_list<<NEWL>>        )<<NEWL>><<NEWL>>    chain = []<<NEWL>>    engines = _engine_list(using)<<NEWL>>    for template_name in template_name_list:<<NEWL>>        for engine in engines:<<NEWL>>            try:<<NEWL>>                return engine.get_template(template_name)<<NEWL>>            except TemplateDoesNotExist as e:<<NEWL>>                chain.append(e)<<NEWL>><<NEWL>>    if template_name_list:<<NEWL>>        raise TemplateDoesNotExist("", "".join(template_name_list), chain=chain)<<NEWL>>    else:<<NEWL>>        raise TemplateDoesNotExist(""No template names provided"")<<NEWL>><<NEWL>><<NEWL>>def render_to_string(template_name, context=None, request=None, using=None):<<NEWL>>    """"""<<NEWL>>    Load a template and render it with a context. Return a string.<<NEWL>><<NEWL>>    template_name may be a string or a list of strings.<<NEWL>>    """"""<<NEWL>>    if isinstance(template_name, (list, tuple)):<<NEWL>>        template = select_template(template_name, using=using)<<NEWL>>    else:<<NEWL>>        template = get_template(template_name, using=using)<<NEWL>>    return template.render(context, request)<<NEWL>><<NEWL>><<NEWL>>def _engine_list(using=None):<<NEWL>>    return engines.all() if using is None else [engines[using]]"
186	adjudicated	4	"import functools<<NEWL>>import logging<<NEWL>>import re<<NEWL>>from typing import NewType, Optional, Tuple, cast<<NEWL>><<NEWL>>from pip._vendor.packaging import specifiers, version<<NEWL>>from pip._vendor.packaging.requirements import Requirement<<NEWL>><<NEWL>>NormalizedExtra = NewType(""NormalizedExtra"", str)<<NEWL>><<NEWL>>logger = logging.getLogger(__name__)<<NEWL>><<NEWL>><<NEWL>>def check_requires_python(<<NEWL>>    requires_python: Optional[str], version_info: Tuple[int, ...]<<NEWL>>) -> bool:<<NEWL>>    """"""<<NEWL>>    Check if the given Python version matches a ""Requires-Python"" specifier.<<NEWL>><<NEWL>>    :param version_info: A 3-tuple of ints representing a Python<<NEWL>>        major-minor-micro version to check (e.g. `sys.version_info[:3]`).<<NEWL>><<NEWL>>    :return: `True` if the given Python version satisfies the requirement.<<NEWL>>        Otherwise, return `False`.<<NEWL>><<NEWL>>    :raises InvalidSpecifier: If `requires_python` has an invalid format.<<NEWL>>    """"""<<NEWL>>    if requires_python is None:<<NEWL>>        # The package provides no information<<NEWL>>        return True<<NEWL>>    requires_python_specifier = specifiers.SpecifierSet(requires_python)<<NEWL>><<NEWL>>    python_version = version.parse(""."".join(map(str, version_info)))<<NEWL>>    return python_version in requires_python_specifier<<NEWL>><<NEWL>><<NEWL>>@functools.lru_cache(maxsize=512)<<NEWL>>def get_requirement(req_string: str) -> Requirement:<<NEWL>>    """"""Construct a packaging.Requirement object with caching""""""<<NEWL>>    # Parsing requirement strings is expensive, and is also expected to happen<<NEWL>>    # with a low diversity of different arguments (at least relative the number<<NEWL>>    # constructed). This method adds a cache to requirement object creation to<<NEWL>>    # minimize repeated parsing of the same string to construct equivalent<<NEWL>>    # Requirement objects.<<NEWL>>    return Requirement(req_string)<<NEWL>><<NEWL>><<NEWL>>def safe_extra(extra: str) -> NormalizedExtra:<<NEWL>>    """"""Convert an arbitrary string to a standard 'extra' name<<NEWL>><<NEWL>>    Any runs of non-alphanumeric characters are replaced with a single '_',<<NEWL>>    and the result is always lowercased.<<NEWL>><<NEWL>>    This function is duplicated from ``pkg_resources``. Note that this is not<<NEWL>>    the same to either ``canonicalize_name`` or ``_egg_link_name``.<<NEWL>>    """"""<<NEWL>>    return cast(NormalizedExtra, re.sub(""[^A-Za-z0-9.-]+"", ""_"", extra).lower())"
357	adjudicated	0	from typing import List<<NEWL>>from collections import deque<<NEWL>><<NEWL>>class Solution:<<NEWL>>    def maxAreaofIsland(self, grid: List[List[int]]) -> int:<<NEWL>>        row = len(grid)<<NEWL>>        col = len(grid[0])<<NEWL>>        biggest_island = 0<<NEWL>>        visited = [[False for i in range(col)] for j in range(row)]<<NEWL>>        for i in range(row):<<NEWL>>            for j in range(col):<<NEWL>>                if grid[i][j] == 1 and visited[i][j] is False:<<NEWL>>                    island_area = self.visitIsland(grid, visited, i,j)<<NEWL>>                    biggest_island = max(island_area,biggest_island)<<NEWL>>        return biggest_island<<NEWL>><<NEWL>>    def visitIsland(self, grid: List[List[int]], visited: List[List[int]], i: int, j: int) -> int:<<NEWL>>        neighbours = deque([(i,j)])<<NEWL>>        area = 0<<NEWL>>        while neighbours:<<NEWL>>            row,col = neighbours.popleft()<<NEWL>>            if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]):<<NEWL>>                continue<<NEWL>>            if visited[row][col] is False and grid[row][col] == 1:<<NEWL>>                visited[row][col] = True<<NEWL>>                area += 1<<NEWL>>                neighbours.extend([(row + 1,col)])<<NEWL>>                neighbours.extend([(row - 1, col)])<<NEWL>>                neighbours.extend([(row, col + 1)])<<NEWL>>                neighbours.extend([(row, col - 1)])<<NEWL>>        return area<<NEWL>><<NEWL>>if __name__ == '__main__':<<NEWL>>    solution = Solution()<<NEWL>>    case1 = [[0,0,0,0,0,0,0,0]]<<NEWL>>    assert solution.maxAreaofIsland(case1) == 0<<NEWL>><<NEWL>>    case2 = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],<<NEWL>>             [0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]<<NEWL>>    assert solution.maxAreaofIsland(case2) == 6<<NEWL>><<NEWL>>    case3 = [[1, 1, 1, 0, 0], [0, 1, 0, 0, 1], [0, 0, 1, 1, 0], [0, 1, 1, 0, 0], [0, 0, 1, 0, 0]]<<NEWL>><<NEWL>>    assert solution.maxAreaofIsland(case3) == 5
419	adjudicated	2	"import _plotly_utils.basevalidators<<NEWL>><<NEWL>><<NEWL>>class InsidetextfontValidator(_plotly_utils.basevalidators.CompoundValidator):<<NEWL>>    def __init__(self, plotly_name=""insidetextfont"", parent_name=""pie"", **kwargs):<<NEWL>>        super(InsidetextfontValidator, self).__init__(<<NEWL>>            plotly_name=plotly_name,<<NEWL>>            parent_name=parent_name,<<NEWL>>            data_class_str=kwargs.pop(""data_class_str"", ""Insidetextfont""),<<NEWL>>            data_docs=kwargs.pop(<<NEWL>>                ""data_docs"",<<NEWL>>                """"""<<NEWL>>            color<<NEWL>><<NEWL>>            colorsrc<<NEWL>>                Sets the source reference on Chart Studio Cloud<<NEWL>>                for `color`.<<NEWL>>            family<<NEWL>>                HTML font family - the typeface that will be<<NEWL>>                applied by the web browser. The web browser<<NEWL>>                will only be able to apply a font if it is<<NEWL>>                available on the system which it operates.<<NEWL>>                Provide multiple font families, separated by<<NEWL>>                commas, to indicate the preference in which to<<NEWL>>                apply fonts if they aren't available on the<<NEWL>>                system. The Chart Studio Cloud (at<<NEWL>>                https://chart-studio.plotly.com or on-premise)<<NEWL>>                generates images on a server, where only a<<NEWL>>                select number of fonts are installed and<<NEWL>>                supported. These include ""Arial"", ""Balto"",<<NEWL>>                ""Courier New"", ""Droid Sans"",, ""Droid Serif"",<<NEWL>>                ""Droid Sans Mono"", ""Gravitas One"", ""Old<<NEWL>>                Standard TT"", ""Open Sans"", ""Overpass"", ""PT Sans<<NEWL>>                Narrow"", ""Raleway"", ""Times New Roman"".<<NEWL>>            familysrc<<NEWL>>                Sets the source reference on Chart Studio Cloud<<NEWL>>                for `family`.<<NEWL>>            size<<NEWL>><<NEWL>>            sizesrc<<NEWL>>                Sets the source reference on Chart Studio Cloud<<NEWL>>                for `size`.<<NEWL>>"""""",<<NEWL>>            ),<<NEWL>>            **kwargs,<<NEWL>>        )"
508	adjudicated	1	"#<<NEWL>># Copyright 2018 the original author or authors.<<NEWL>>#<<NEWL>># Licensed under the Apache License, Version 2.0 (the ""License"");<<NEWL>># you may not use this file except in compliance with the License.<<NEWL>># You may obtain a copy of the License at<<NEWL>>#<<NEWL>>#      http://www.apache.org/licenses/LICENSE-2.0<<NEWL>>#<<NEWL>># Unless required by applicable law or agreed to in writing, software<<NEWL>># distributed under the License is distributed on an ""AS IS"" BASIS,<<NEWL>># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<<NEWL>># See the License for the specific language governing permissions and<<NEWL>># limitations under the License.<<NEWL>>#<<NEWL>>from google.protobuf.json_format import MessageToDict<<NEWL>>from google.protobuf.message import Message<<NEWL>>from simplejson import dumps<<NEWL>>from common.event_bus import EventBusClient<<NEWL>>from voltha.protos.omci_mib_db_pb2 import OpenOmciEvent<<NEWL>>from voltha.protos.omci_alarm_db_pb2 import AlarmOpenOmciEvent<<NEWL>>from common.utils.json_format import MessageToDict<<NEWL>><<NEWL>><<NEWL>>class OpenOmciEventBus(object):<<NEWL>>    """""" Event bus for publishing OpenOMCI related events. """"""<<NEWL>>    __slots__ = (<<NEWL>>        '_event_bus_client',  # The event bus client used to publish events.<<NEWL>>        '_topic'              # the topic to publish to<<NEWL>>    )<<NEWL>><<NEWL>>    def __init__(self):<<NEWL>>        self._event_bus_client = EventBusClient()<<NEWL>>        self._topic = 'openomci-events'<<NEWL>><<NEWL>>    def message_to_dict(m):<<NEWL>>        return MessageToDict(m, True, True, False)<<NEWL>><<NEWL>>    def advertise(self, event_type, data):<<NEWL>>        if isinstance(data, Message):<<NEWL>>            msg = dumps(MessageToDict(data, True, True))<<NEWL>>        elif isinstance(data, dict):<<NEWL>>            msg = dumps(data)<<NEWL>>        else:<<NEWL>>            msg = str(data)<<NEWL>><<NEWL>>        event_func = AlarmOpenOmciEvent if 'AlarmSynchronizer' in msg \<<NEWL>>                                  else OpenOmciEvent<<NEWL>>        event = event_func(<<NEWL>>                type=event_type,<<NEWL>>                data=msg<<NEWL>>        )<<NEWL>><<NEWL>>        self._event_bus_client.publish(self._topic, event)"
448	adjudicated	1	"# -*- coding: utf-8 -<<NEWL>>#<<NEWL>># This file is part of gunicorn released under the MIT license.<<NEWL>># See the NOTICE for more information.<<NEWL>><<NEWL>>import os<<NEWL>><<NEWL>>from gunicorn.errors import ConfigError<<NEWL>>from gunicorn.app.base import Application<<NEWL>>from gunicorn import util<<NEWL>><<NEWL>><<NEWL>>class WSGIApplication(Application):<<NEWL>>    def init(self, parser, opts, args):<<NEWL>>        self.app_uri = None<<NEWL>><<NEWL>>        if opts.paste:<<NEWL>>            from .pasterapp import has_logging_config<<NEWL>><<NEWL>>            config_uri = os.path.abspath(opts.paste)<<NEWL>>            config_file = config_uri.split('#')[0]<<NEWL>><<NEWL>>            if not os.path.exists(config_file):<<NEWL>>                raise ConfigError(""%r not found"" % config_file)<<NEWL>><<NEWL>>            self.cfg.set(""default_proc_name"", config_file)<<NEWL>>            self.app_uri = config_uri<<NEWL>><<NEWL>>            if has_logging_config(config_file):<<NEWL>>                self.cfg.set(""logconfig"", config_file)<<NEWL>><<NEWL>>            return<<NEWL>><<NEWL>>        if len(args) > 0:<<NEWL>>            self.cfg.set(""default_proc_name"", args[0])<<NEWL>>            self.app_uri = args[0]<<NEWL>><<NEWL>>    def load_config(self):<<NEWL>>        super().load_config()<<NEWL>><<NEWL>>        if self.app_uri is None:<<NEWL>>            if self.cfg.wsgi_app is not None:<<NEWL>>                self.app_uri = self.cfg.wsgi_app<<NEWL>>            else:<<NEWL>>                raise ConfigError(""No application module specified."")<<NEWL>><<NEWL>>    def load_wsgiapp(self):<<NEWL>>        return util.import_app(self.app_uri)<<NEWL>><<NEWL>>    def load_pasteapp(self):<<NEWL>>        from .pasterapp import get_wsgi_app<<NEWL>>        return get_wsgi_app(self.app_uri, defaults=self.cfg.paste_global_conf)<<NEWL>><<NEWL>>    def load(self):<<NEWL>>        if self.cfg.paste is not None:<<NEWL>>            return self.load_pasteapp()<<NEWL>>        else:<<NEWL>>            return self.load_wsgiapp()<<NEWL>><<NEWL>><<NEWL>>def run():<<NEWL>>    """"""\<<NEWL>>    The ``gunicorn`` command line runner for launching Gunicorn with<<NEWL>>    generic WSGI applications.<<NEWL>>    """"""<<NEWL>>    from gunicorn.app.wsgiapp import WSGIApplication<<NEWL>>    WSGIApplication(""%(prog)s [OPTIONS] [APP_MODULE]"").run()<<NEWL>><<NEWL>><<NEWL>>if __name__ == '__main__':<<NEWL>>    run()"
458	adjudicated	2	"# This file is part of Scapy<<NEWL>># See http://www.secdev.org/projects/scapy for more information<<NEWL>># Copyright (C) Philippe Biondi <phil@secdev.org><<NEWL>># This program is published under a GPLv2 license<<NEWL>><<NEWL>>""""""<<NEWL>>External link to programs<<NEWL>>""""""<<NEWL>><<NEWL>>import os<<NEWL>>import subprocess<<NEWL>>from scapy.error import log_loading<<NEWL>><<NEWL>># Notice: this file must not be called before main.py, if started<<NEWL>># in interactive mode, because it needs to be called after the<<NEWL>># logger has been setup, to be able to print the warning messages<<NEWL>><<NEWL>># MATPLOTLIB<<NEWL>><<NEWL>>try:<<NEWL>>    from matplotlib import get_backend as matplotlib_get_backend<<NEWL>>    from matplotlib import pyplot as plt<<NEWL>>    from matplotlib.lines import Line2D<<NEWL>>    MATPLOTLIB = 1<<NEWL>>    if ""inline"" in matplotlib_get_backend():<<NEWL>>        MATPLOTLIB_INLINED = 1<<NEWL>>    else:<<NEWL>>        MATPLOTLIB_INLINED = 0<<NEWL>>    MATPLOTLIB_DEFAULT_PLOT_KARGS = {""marker"": ""+""}<<NEWL>># RuntimeError to catch gtk ""Cannot open display"" error<<NEWL>>except (ImportError, RuntimeError):<<NEWL>>    plt = None<<NEWL>>    Line2D = None<<NEWL>>    MATPLOTLIB = 0<<NEWL>>    MATPLOTLIB_INLINED = 0<<NEWL>>    MATPLOTLIB_DEFAULT_PLOT_KARGS = dict()<<NEWL>>    log_loading.info(""Can't import matplotlib. Won't be able to plot."")<<NEWL>><<NEWL>># PYX<<NEWL>><<NEWL>><<NEWL>>def _test_pyx():<<NEWL>>    # type: () -> bool<<NEWL>>    """"""Returns if PyX is correctly installed or not""""""<<NEWL>>    try:<<NEWL>>        with open(os.devnull, 'wb') as devnull:<<NEWL>>            r = subprocess.check_call([""pdflatex"", ""--version""],<<NEWL>>                                      stdout=devnull, stderr=subprocess.STDOUT)<<NEWL>>    except (subprocess.CalledProcessError, OSError):<<NEWL>>        return False<<NEWL>>    else:<<NEWL>>        return r == 0<<NEWL>><<NEWL>><<NEWL>>try:<<NEWL>>    import pyx  # noqa: F401<<NEWL>>    if _test_pyx():<<NEWL>>        PYX = 1<<NEWL>>    else:<<NEWL>>        log_loading.info(""PyX dependencies are not installed ! Please install TexLive or MikTeX."")  # noqa: E501<<NEWL>>        PYX = 0<<NEWL>>except ImportError:<<NEWL>>    log_loading.info(""Can't import PyX. Won't be able to use psdump() or pdfdump()."")  # noqa: E501<<NEWL>>    PYX = 0"
409	adjudicated	2	"import os<<NEWL>>import json<<NEWL>><<NEWL>>import torch<<NEWL>>from PIL import Image<<NEWL>>from torchvision import transforms<<NEWL>>import matplotlib.pyplot as plt<<NEWL>><<NEWL>>from vit_model import vit_base_patch16_224_in21k as create_model<<NEWL>><<NEWL>><<NEWL>>def main():<<NEWL>>    device = torch.device(""cuda:0"" if torch.cuda.is_available() else ""cpu"")<<NEWL>><<NEWL>>    data_transform = transforms.Compose(<<NEWL>>        [transforms.Resize(256),<<NEWL>>         transforms.CenterCrop(224),<<NEWL>>         transforms.ToTensor(),<<NEWL>>         transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5])])<<NEWL>><<NEWL>>    # load image<<NEWL>>    img_path = ""../tulip.jpg""<<NEWL>>    assert os.path.exists(img_path), ""file: '{}' dose not exist."".format(img_path)<<NEWL>>    img = Image.open(img_path)<<NEWL>>    plt.imshow(img)<<NEWL>>    # [N, C, H, W]<<NEWL>>    img = data_transform(img)<<NEWL>>    # expand batch dimension<<NEWL>>    img = torch.unsqueeze(img, dim=0)<<NEWL>><<NEWL>>    # read class_indict<<NEWL>>    json_path = './class_indices.json'<<NEWL>>    assert os.path.exists(json_path), ""file: '{}' dose not exist."".format(json_path)<<NEWL>><<NEWL>>    with open(json_path, ""r"") as f:<<NEWL>>        class_indict = json.load(f)<<NEWL>><<NEWL>>    # create model<<NEWL>>    model = create_model(num_classes=5, has_logits=False).to(device)<<NEWL>>    # load model weights<<NEWL>>    model_weight_path = ""./weights/model-9.pth""<<NEWL>>    model.load_state_dict(torch.load(model_weight_path, map_location=device))<<NEWL>>    model.eval()<<NEWL>>    with torch.no_grad():<<NEWL>>        # predict class<<NEWL>>        output = torch.squeeze(model(img.to(device))).cpu()<<NEWL>>        predict = torch.softmax(output, dim=0)<<NEWL>>        predict_cla = torch.argmax(predict).numpy()<<NEWL>><<NEWL>>    print_res = ""class: {}   prob: {:.3}"".format(class_indict[str(predict_cla)],<<NEWL>>                                                 predict[predict_cla].numpy())<<NEWL>>    plt.title(print_res)<<NEWL>>    for i in range(len(predict)):<<NEWL>>        print(""class: {:10}   prob: {:.3}"".format(class_indict[str(i)],<<NEWL>>                                                  predict[i].numpy()))<<NEWL>>    plt.show()<<NEWL>><<NEWL>><<NEWL>>if __name__ == '__main__':<<NEWL>>    main()"
347	adjudicated	0	"from functools import partial<<NEWL>><<NEWL>>import pytest<<NEWL>><<NEWL>>from ..argument import Argument, to_arguments<<NEWL>>from ..field import Field<<NEWL>>from ..inputfield import InputField<<NEWL>>from ..scalars import String<<NEWL>>from ..structures import NonNull<<NEWL>><<NEWL>><<NEWL>>def test_argument():<<NEWL>>    arg = Argument(String, default_value=""a"", description=""desc"", name=""b"")<<NEWL>>    assert arg.type == String<<NEWL>>    assert arg.default_value == ""a""<<NEWL>>    assert arg.description == ""desc""<<NEWL>>    assert arg.name == ""b""<<NEWL>><<NEWL>><<NEWL>>def test_argument_comparasion():<<NEWL>>    arg1 = Argument(String, name=""Hey"", description=""Desc"", default_value=""default"")<<NEWL>>    arg2 = Argument(String, name=""Hey"", description=""Desc"", default_value=""default"")<<NEWL>><<NEWL>>    assert arg1 == arg2<<NEWL>>    assert arg1 != String()<<NEWL>><<NEWL>><<NEWL>>def test_argument_required():<<NEWL>>    arg = Argument(String, required=True)<<NEWL>>    assert arg.type == NonNull(String)<<NEWL>><<NEWL>><<NEWL>>def test_to_arguments():<<NEWL>>    args = {""arg_string"": Argument(String), ""unmounted_arg"": String(required=True)}<<NEWL>><<NEWL>>    my_args = to_arguments(args)<<NEWL>>    assert my_args == {<<NEWL>>        ""arg_string"": Argument(String),<<NEWL>>        ""unmounted_arg"": Argument(String, required=True),<<NEWL>>    }<<NEWL>><<NEWL>><<NEWL>>def test_to_arguments_raises_if_field():<<NEWL>>    args = {""arg_string"": Field(String)}<<NEWL>><<NEWL>>    with pytest.raises(ValueError) as exc_info:<<NEWL>>        to_arguments(args)<<NEWL>><<NEWL>>    assert str(exc_info.value) == (<<NEWL>>        ""Expected arg_string to be Argument, but received Field. Try using ""<<NEWL>>        ""Argument(String).""<<NEWL>>    )<<NEWL>><<NEWL>><<NEWL>>def test_to_arguments_raises_if_inputfield():<<NEWL>>    args = {""arg_string"": InputField(String)}<<NEWL>><<NEWL>>    with pytest.raises(ValueError) as exc_info:<<NEWL>>        to_arguments(args)<<NEWL>><<NEWL>>    assert str(exc_info.value) == (<<NEWL>>        ""Expected arg_string to be Argument, but received InputField. Try ""<<NEWL>>        ""using Argument(String).""<<NEWL>>    )<<NEWL>><<NEWL>><<NEWL>>def test_argument_with_lazy_type():<<NEWL>>    MyType = object()<<NEWL>>    arg = Argument(lambda: MyType)<<NEWL>>    assert arg.type == MyType<<NEWL>><<NEWL>><<NEWL>>def test_argument_with_lazy_partial_type():<<NEWL>>    MyType = object()<<NEWL>>    arg = Argument(partial(lambda: MyType))<<NEWL>>    assert arg.type == MyType"
207	adjudicated	3	"###############################################################################<<NEWL>>#<<NEWL>># The MIT License (MIT)<<NEWL>>#<<NEWL>># Copyright (c) typedef int GmbH<<NEWL>>#<<NEWL>># Permission is hereby granted, free of charge, to any person obtaining a copy<<NEWL>># of this software and associated documentation files (the ""Software""), to deal<<NEWL>># in the Software without restriction, including without limitation the rights<<NEWL>># to use, copy, modify, merge, publish, distribute, sublicense, and/or sell<<NEWL>># copies of the Software, and to permit persons to whom the Software is<<NEWL>># furnished to do so, subject to the following conditions:<<NEWL>>#<<NEWL>># The above copyright notice and this permission notice shall be included in<<NEWL>># all copies or substantial portions of the Software.<<NEWL>>#<<NEWL>># THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<<NEWL>># IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<<NEWL>># FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE<<NEWL>># AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER<<NEWL>># LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,<<NEWL>># OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN<<NEWL>># THE SOFTWARE.<<NEWL>>#<<NEWL>>###############################################################################<<NEWL>><<NEWL>>import platform<<NEWL>><<NEWL>>import autobahn<<NEWL>><<NEWL>># WebSocket protocol support<<NEWL>>from autobahn.asyncio.websocket import \<<NEWL>>    WebSocketServerProtocol, \<<NEWL>>    WebSocketClientProtocol, \<<NEWL>>    WebSocketServerFactory, \<<NEWL>>    WebSocketClientFactory<<NEWL>><<NEWL>># WAMP support<<NEWL>>from autobahn.asyncio.wamp import ApplicationSession<<NEWL>><<NEWL>><<NEWL>>__all__ = (<<NEWL>>    'WebSocketServerProtocol',<<NEWL>>    'WebSocketClientProtocol',<<NEWL>>    'WebSocketServerFactory',<<NEWL>>    'WebSocketClientFactory',<<NEWL>>    'ApplicationSession',<<NEWL>>)<<NEWL>><<NEWL>>__ident__ = 'Autobahn/{}-asyncio-{}/{}'.format(autobahn.__version__, platform.python_implementation(), platform.python_version())<<NEWL>>""""""<<NEWL>>AutobahnPython library implementation (eg. ""Autobahn/0.13.0-asyncio-CPython/3.5.1"")<<NEWL>>"""""""
196	adjudicated	3	"""""""<<NEWL>>    pygments.styles.perldoc<<NEWL>>    ~~~~~~~~~~~~~~~~~~~~~~~<<NEWL>><<NEWL>>    Style similar to the style used in the `perldoc`_ code blocks.<<NEWL>><<NEWL>>    .. _perldoc: http://perldoc.perl.org/<<NEWL>><<NEWL>>    :copyright: Copyright 2006-2022 by the Pygments team, see AUTHORS.<<NEWL>>    :license: BSD, see LICENSE for details.<<NEWL>>""""""<<NEWL>><<NEWL>>from pygments.style import Style<<NEWL>>from pygments.token import Keyword, Name, Comment, String, Error, \<<NEWL>>     Number, Operator, Generic, Whitespace<<NEWL>><<NEWL>><<NEWL>>class PerldocStyle(Style):<<NEWL>>    """"""<<NEWL>>    Style similar to the style used in the perldoc code blocks.<<NEWL>>    """"""<<NEWL>><<NEWL>>    background_color = '#eeeedd'<<NEWL>><<NEWL>>    styles = {<<NEWL>>        Whitespace:             '#bbbbbb',<<NEWL>>        Comment:                '#228B22',<<NEWL>>        Comment.Preproc:        '#1e889b',<<NEWL>>        Comment.Special:        '#8B008B bold',<<NEWL>><<NEWL>>        String:                 '#CD5555',<<NEWL>>        String.Heredoc:         '#1c7e71 italic',<<NEWL>>        String.Regex:           '#B452CD',<<NEWL>>        String.Other:           '#cb6c20',<<NEWL>>        String.Regex:           '#1c7e71',<<NEWL>><<NEWL>>        Number:                 '#B452CD',<<NEWL>><<NEWL>>        Operator.Word:          '#8B008B',<<NEWL>><<NEWL>>        Keyword:                '#8B008B bold',<<NEWL>>        Keyword.Type:           '#00688B',<<NEWL>><<NEWL>>        Name.Class:             '#008b45 bold',<<NEWL>>        Name.Exception:         '#008b45 bold',<<NEWL>>        Name.Function:          '#008b45',<<NEWL>>        Name.Namespace:         '#008b45 underline',<<NEWL>>        Name.Variable:          '#00688B',<<NEWL>>        Name.Constant:          '#00688B',<<NEWL>>        Name.Decorator:         '#707a7c',<<NEWL>>        Name.Tag:               '#8B008B bold',<<NEWL>>        Name.Attribute:         '#658b00',<<NEWL>>        Name.Builtin:           '#658b00',<<NEWL>><<NEWL>>        Generic.Heading:        'bold #000080',<<NEWL>>        Generic.Subheading:     'bold #800080',<<NEWL>>        Generic.Deleted:        '#aa0000',<<NEWL>>        Generic.Inserted:       '#00aa00',<<NEWL>>        Generic.Error:          '#aa0000',<<NEWL>>        Generic.Emph:           'italic',<<NEWL>>        Generic.Strong:         'bold',<<NEWL>>        Generic.Prompt:         '#555555',<<NEWL>>        Generic.Output:         '#888888',<<NEWL>>        Generic.Traceback:      '#aa0000',<<NEWL>><<NEWL>>        Error:                  'bg:#e3d2d2 #a61717'<<NEWL>>    }"
316	adjudicated	3	import numpy as np<<NEWL>>import numba<<NEWL>><<NEWL>># - plotStratigraphy takes 1) XorY_StratiOverTime (time and either x or y dimensions): strati__elevation selected for only the basin area and either averaged or selected for one across (y)/down(x) basin distance <<NEWL>>#     2) XorY_GrainSizeOverTime (time and either x or y dimensions) the grain size or erosion rate or other desired variable that will be used to fill the stratigraphy. This also needs to be selected or averaged for one x/y distance. <<NEWL>># - stratigraphy as it is written assumes that channels are draining either in the x or y direction (mountain along one axis) and stratigraphy is generated along one axis.     <<NEWL>># - plotStratigraphy averages the nearby nodes (grain size or erosion rate or other desired value passed) to fill a given cell of stratigraphy.<<NEWL>># -plotStraigraphy2 does not average the nearest nodes and takes the first closest value to fill the stratigraphy. <<NEWL>><<NEWL>>@numba.njit<<NEWL>>def plotStratigraphy(XorY_StratiOverTime,XorY_GrainSizeOverTime):<<NEWL>>    i=0<<NEWL>>    j=0<<NEWL>>    C=np.zeros(((XorY_StratiOverTime.shape[0]),(XorY_StratiOverTime.shape[1])))<<NEWL>>    for i in range(0,(XorY_StratiOverTime.shape[1])):<<NEWL>>        for j in range(0,(XorY_StratiOverTime.shape[0])):<<NEWL>>            tryff=np.array([XorY_GrainSizeOverTime[j,i],XorY_GrainSizeOverTime[j,i+1],XorY_GrainSizeOverTime[j+1,i],XorY_GrainSizeOverTime[j+1,i+1]])<<NEWL>>            C[j,i]=np.nanmean(tryff)<<NEWL>>    return C<<NEWL>><<NEWL>>@numba.njit<<NEWL>>def plotStratigraphy2(XorY_StratiOverTime,XorY_GrainSizeOverTime):<<NEWL>>    i=0<<NEWL>>    j=0<<NEWL>>    C=np.zeros(((XorY_StratiOverTime.shape[0]),(XorY_StratiOverTime.shape[1])))<<NEWL>>    for i in range(0,(XorY_StratiOverTime.shape[1])):<<NEWL>>        for j in range(0,(XorY_StratiOverTime.shape[0])):<<NEWL>>            #tryff=np.array([XorY_GrainSizeOverTime[j,i],XorY_GrainSizeOverTime[j,i+1],XorY_GrainSizeOverTime[j+1,i],XorY_GrainSizeOverTime[j+1,i+1]])<<NEWL>>            C[j,i]=(XorY_GrainSizeOverTime[j,i])<<NEWL>>    return C
87	adjudicated	0	"import threading<<NEWL>><<NEWL>>from pydantic import BaseModel<<NEWL>><<NEWL>>from prowler.lib.logger import logger<<NEWL>>from prowler.providers.aws.aws_provider import generate_regional_clients<<NEWL>><<NEWL>><<NEWL>>################## SecretsManager<<NEWL>>class SecretsManager:<<NEWL>>    def __init__(self, audit_info):<<NEWL>>        self.service = ""secretsmanager""<<NEWL>>        self.session = audit_info.audit_session<<NEWL>>        self.audited_account = audit_info.audited_account<<NEWL>>        self.regional_clients = generate_regional_clients(self.service, audit_info)<<NEWL>>        self.secrets = {}<<NEWL>>        self.__threading_call__(self.__list_secrets__)<<NEWL>><<NEWL>>    def __get_session__(self):<<NEWL>>        return self.session<<NEWL>><<NEWL>>    def __threading_call__(self, call):<<NEWL>>        threads = []<<NEWL>>        for regional_client in self.regional_clients.values():<<NEWL>>            threads.append(threading.Thread(target=call, args=(regional_client,)))<<NEWL>>        for t in threads:<<NEWL>>            t.start()<<NEWL>>        for t in threads:<<NEWL>>            t.join()<<NEWL>><<NEWL>>    def __list_secrets__(self, regional_client):<<NEWL>>        logger.info(""SecretsManager - Listing Secrets..."")<<NEWL>>        try:<<NEWL>>            list_secrets_paginator = regional_client.get_paginator(""list_secrets"")<<NEWL>>            for page in list_secrets_paginator.paginate():<<NEWL>>                for secret in page[""SecretList""]:<<NEWL>>                    self.secrets[secret[""Name""]] = Secret(<<NEWL>>                        arn=secret[""ARN""],<<NEWL>>                        name=secret[""Name""],<<NEWL>>                        region=regional_client.region,<<NEWL>>                    )<<NEWL>>                    if ""RotationEnabled"" in secret:<<NEWL>>                        self.secrets[secret[""Name""]].rotation_enabled = secret[<<NEWL>>                            ""RotationEnabled""<<NEWL>>                        ]<<NEWL>><<NEWL>>        except Exception as error:<<NEWL>>            logger.error(<<NEWL>>                f""{regional_client.region} --""<<NEWL>>                f"" {error.__class__.__name__}[{error.__traceback__.tb_lineno}]:""<<NEWL>>                f"" {error}""<<NEWL>>            )<<NEWL>><<NEWL>><<NEWL>>class Secret(BaseModel):<<NEWL>>    arn: str<<NEWL>>    name: str<<NEWL>>    region: str<<NEWL>>    rotation_enabled: bool = False"
256	adjudicated	1	"import win32api, win32security<<NEWL>>import win32con, ntsecuritycon, winnt<<NEWL>>import os<<NEWL>><<NEWL>>temp_dir = win32api.GetTempPath()<<NEWL>>fname = win32api.GetTempFileName(temp_dir, ""rsk"")[0]<<NEWL>>print(fname)<<NEWL>>## file can't exist<<NEWL>>os.remove(fname)<<NEWL>><<NEWL>>## enable backup and restore privs<<NEWL>>required_privs = (<<NEWL>>    (<<NEWL>>        win32security.LookupPrivilegeValue("""", ntsecuritycon.SE_BACKUP_NAME),<<NEWL>>        win32con.SE_PRIVILEGE_ENABLED,<<NEWL>>    ),<<NEWL>>    (<<NEWL>>        win32security.LookupPrivilegeValue("""", ntsecuritycon.SE_RESTORE_NAME),<<NEWL>>        win32con.SE_PRIVILEGE_ENABLED,<<NEWL>>    ),<<NEWL>>)<<NEWL>>ph = win32api.GetCurrentProcess()<<NEWL>>th = win32security.OpenProcessToken(<<NEWL>>    ph, win32con.TOKEN_READ | win32con.TOKEN_ADJUST_PRIVILEGES<<NEWL>>)<<NEWL>>adjusted_privs = win32security.AdjustTokenPrivileges(th, 0, required_privs)<<NEWL>><<NEWL>>try:<<NEWL>>    sa = win32security.SECURITY_ATTRIBUTES()<<NEWL>>    my_sid = win32security.GetTokenInformation(th, ntsecuritycon.TokenUser)[0]<<NEWL>>    sa.SECURITY_DESCRIPTOR.SetSecurityDescriptorOwner(my_sid, 0)<<NEWL>><<NEWL>>    k, disp = win32api.RegCreateKeyEx(<<NEWL>>        win32con.HKEY_CURRENT_USER,<<NEWL>>        ""Python test key"",<<NEWL>>        SecurityAttributes=sa,<<NEWL>>        samDesired=win32con.KEY_ALL_ACCESS,<<NEWL>>        Class=""some class"",<<NEWL>>        Options=0,<<NEWL>>    )<<NEWL>>    win32api.RegSetValue(k, None, win32con.REG_SZ, ""Default value for python test key"")<<NEWL>><<NEWL>>    subk, disp = win32api.RegCreateKeyEx(<<NEWL>>        k,<<NEWL>>        ""python test subkey"",<<NEWL>>        SecurityAttributes=sa,<<NEWL>>        samDesired=win32con.KEY_ALL_ACCESS,<<NEWL>>        Class=""some other class"",<<NEWL>>        Options=0,<<NEWL>>    )<<NEWL>>    win32api.RegSetValue(subk, None, win32con.REG_SZ, ""Default value for subkey"")<<NEWL>><<NEWL>>    win32api.RegSaveKeyEx(<<NEWL>>        k, fname, Flags=winnt.REG_STANDARD_FORMAT, SecurityAttributes=sa<<NEWL>>    )<<NEWL>><<NEWL>>    restored_key, disp = win32api.RegCreateKeyEx(<<NEWL>>        win32con.HKEY_CURRENT_USER,<<NEWL>>        ""Python test key(restored)"",<<NEWL>>        SecurityAttributes=sa,<<NEWL>>        samDesired=win32con.KEY_ALL_ACCESS,<<NEWL>>        Class=""restored class"",<<NEWL>>        Options=0,<<NEWL>>    )<<NEWL>>    win32api.RegRestoreKey(restored_key, fname)<<NEWL>>finally:<<NEWL>>    win32security.AdjustTokenPrivileges(th, 0, adjusted_privs)"
74	adjudicated	1	"import sys<<NEWL>>import time<<NEWL>><<NEWL>>import log4p<<NEWL>>import pcloud<<NEWL>><<NEWL>>log = log4p.GetLogger(__name__, config=""log4p.json"").logger<<NEWL>><<NEWL>><<NEWL>>class Uploader:<<NEWL>><<NEWL>>    def __init__(self, username, password):<<NEWL>>        self.pc = pcloud.PyCloud(username, password)<<NEWL>>        self.path = '/'<<NEWL>><<NEWL>>    def is_logged_in(self):<<NEWL>>        return len(self.pc.auth_token) > 1<<NEWL>><<NEWL>>    def set_path(self, path):<<NEWL>>        self.pc.createfolderifnotexists(path=path)<<NEWL>>        self.path = path<<NEWL>><<NEWL>>    def upload(self, file):<<NEWL>>        response = self.pc.uploadfile(files=[file], path=self.path)<<NEWL>>        log.debug(response)<<NEWL>>        if response['result'] == 0:<<NEWL>>            log.info('Uploaded the file  %s file to pcloud %s', file, self.path)<<NEWL>>            time.sleep(1)<<NEWL>>            return<<NEWL>>        log.error(""Was not able to upload to pcloud"")<<NEWL>>        sys.exit(response['result'])<<NEWL>><<NEWL>>    def get_checksum(self, file):<<NEWL>>        response = self.pc.checksumfile(path=self.path+'/'+file)<<NEWL>>        log.debug(response)<<NEWL>>        return response['sha1']<<NEWL>><<NEWL>>    def is_file_present(self, file):<<NEWL>>        response = self.pc.listfolder(path=self.path)<<NEWL>>        log.debug(response)<<NEWL>>        dir_content = response['metadata']['contents']<<NEWL>>        for item in dir_content:<<NEWL>>            if item['name'] == file:<<NEWL>>                log.info(""File %s is present in directory %s"", file, self.path)<<NEWL>>                return True<<NEWL>>        log.info(""File %s not found in directory %s"", file, self.path)<<NEWL>>        return False<<NEWL>><<NEWL>>    def rename_file(self, file, new_name):<<NEWL>>        response = self.pc.renamefile(<<NEWL>>            path=self.path+'/'+file,<<NEWL>>            topath=self.path+'/'+new_name<<NEWL>>        )<<NEWL>>        log.debug(response)<<NEWL>>        if response['result'] == 0:<<NEWL>>            log.info(""File %s renamed to %s"", file, new_name)<<NEWL>>            time.sleep(1)<<NEWL>>            return<<NEWL>>        log.error(""Failed to rename file %s to %s"", file, new_name)<<NEWL>><<NEWL>>    def delete_file(self, file):<<NEWL>>        response = self.pc.deletefile(path=self.path+'/'+file)<<NEWL>>        log.debug(response)<<NEWL>>        if response['result'] == 0:<<NEWL>>            log.info(""File %s deleted"", file)<<NEWL>>            return<<NEWL>>"
134	adjudicated	0	######################## BEGIN LICENSE BLOCK ########################<<NEWL>># The Original Code is Mozilla Universal charset detector code.<<NEWL>>#<<NEWL>># The Initial Developer of the Original Code is<<NEWL>># Netscape Communications Corporation.<<NEWL>># Portions created by the Initial Developer are Copyright (C) 2001<<NEWL>># the Initial Developer. All Rights Reserved.<<NEWL>>#<<NEWL>># Contributor(s):<<NEWL>>#   Mark Pilgrim - port to Python<<NEWL>>#   Shy Shalom - original C code<<NEWL>>#   Proofpoint, Inc.<<NEWL>>#<<NEWL>># This library is free software; you can redistribute it and/or<<NEWL>># modify it under the terms of the GNU Lesser General Public<<NEWL>># License as published by the Free Software Foundation; either<<NEWL>># version 2.1 of the License, or (at your option) any later version.<<NEWL>>#<<NEWL>># This library is distributed in the hope that it will be useful,<<NEWL>># but WITHOUT ANY WARRANTY; without even the implied warranty of<<NEWL>># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU<<NEWL>># Lesser General Public License for more details.<<NEWL>>#<<NEWL>># You should have received a copy of the GNU Lesser General Public<<NEWL>># License along with this library; if not, write to the Free Software<<NEWL>># Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA<<NEWL>># 02110-1301  USA<<NEWL>>######################### END LICENSE BLOCK #########################<<NEWL>><<NEWL>>from .big5prober import Big5Prober<<NEWL>>from .charsetgroupprober import CharSetGroupProber<<NEWL>>from .cp949prober import CP949Prober<<NEWL>>from .eucjpprober import EUCJPProber<<NEWL>>from .euckrprober import EUCKRProber<<NEWL>>from .euctwprober import EUCTWProber<<NEWL>>from .gb2312prober import GB2312Prober<<NEWL>>from .johabprober import JOHABProber<<NEWL>>from .sjisprober import SJISProber<<NEWL>>from .utf8prober import UTF8Prober<<NEWL>><<NEWL>><<NEWL>>class MBCSGroupProber(CharSetGroupProber):<<NEWL>>    def __init__(self, lang_filter=None):<<NEWL>>        super().__init__(lang_filter=lang_filter)<<NEWL>>        self.probers = [<<NEWL>>            UTF8Prober(),<<NEWL>>            SJISProber(),<<NEWL>>            EUCJPProber(),<<NEWL>>            GB2312Prober(),<<NEWL>>            EUCKRProber(),<<NEWL>>            CP949Prober(),<<NEWL>>            Big5Prober(),<<NEWL>>            EUCTWProber(),<<NEWL>>            JOHABProber(),<<NEWL>>        ]<<NEWL>>        self.reset()
25	adjudicated	0	"from django import forms<<NEWL>>from .models import Todo,Assign_task<<NEWL>>from django.contrib.auth.forms import UserCreationForm<<NEWL>>from django.contrib.auth.models import User<<NEWL>><<NEWL>><<NEWL>>class TaskForm(forms.ModelForm):<<NEWL>><<TAB>>class Meta:<<NEWL>><<TAB>><<TAB>>model = Todo<<NEWL>><<TAB>><<TAB>>fields = (""task"",""completed"",""created_date"",""deadline"")<<NEWL>><<NEWL>><<NEWL>>class AssignForm(forms.ModelForm):<<NEWL>><<TAB>>class Meta:<<NEWL>><<TAB>><<TAB>>model = Assign_task<<NEWL>><<TAB>><<TAB>>fields = ""__all__""<<NEWL>><<NEWL>>class NewUserForm(UserCreationForm):<<NEWL>><<TAB>>email = forms.EmailField(required=True)<<NEWL>><<NEWL>><<TAB>>class Meta:<<NEWL>><<TAB>><<TAB>>model = User<<NEWL>><<TAB>><<TAB>>fields = (""username"", ""email"", ""password1"", ""password2"")<<NEWL>><<NEWL>><<TAB>>def save(self, commit=True):<<NEWL>><<TAB>><<TAB>>user = super(NewUserForm, self).save(commit=False)<<NEWL>><<TAB>><<TAB>>user.email = self.cleaned_data['email']<<NEWL>><<TAB>><<TAB>>if commit:<<NEWL>><<TAB>><<TAB>><<TAB>>user.save()<<NEWL>><<TAB>><<TAB>>return user<<NEWL>><<NEWL>>'''class AssignTaskForm(forms.Form):<<NEWL>>    def __init__(self):              <<NEWL>>        self.choice_list = [('test', 'test'),]        <<NEWL>>        self.users = User.objects.all()        <<NEWL>>        for self.x in self.users:<<NEWL>>            self.choice_list.append([self.x.get_username(), self.x.get_username()])        <<NEWL>>        self.CHOICES = self.choice_list<<NEWL>>        super (AssignTaskForm, self).__init__()<<NEWL>>        self.fields['User_choice'].widget = forms.Select(choices=self.CHOICES) <<NEWL>>        <<NEWL>>    User_choice = forms.CharField(max_length=100)<<NEWL>>    start_date = forms.DateField(widget=forms.SelectDateWidget())<<NEWL>>    end_date = forms.DateField(widget=forms.SelectDateWidget())<<NEWL>><<TAB>>Task_Name = forms.CharField(widget=forms.Textarea)'''<<NEWL>><<NEWL>><<NEWL>>class AssignTaskForm(forms.Form):<<NEWL>><<TAB>>def __init__(self):<<NEWL>><<TAB>><<TAB>>self.choice_list = [('test','test'),]<<NEWL>><<TAB>><<TAB>>self.users = User.objects.all()<<NEWL>><<TAB>><<TAB>>for self.x in self.users:<<NEWL>><<TAB>><<TAB>><<TAB>>self.choice_list.append([self.x.get_username(), self.x.get_username()])<<NEWL>><<TAB>><<TAB>>self.CHOICES = self.choice_list <<NEWL>><<TAB>><<TAB>>super(AssignTaskForm,self).__init__()<<NEWL>><<TAB>><<TAB>>self.fields['SELECT_USER'].widget = forms.Select(choices=self.CHOICES)<<NEWL>><<NEWL>><<TAB>>Task_Name = forms.CharField(widget = forms.TextInput)<<NEWL>><<TAB>>SELECT_USER = forms.CharField(max_length = 100)<<NEWL>><<TAB>>start_date = forms.DateField(widget=forms.SelectDateWidget())<<NEWL>><<TAB>>end_date = forms.DateField(widget=forms.SelectDateWidget())"
165	adjudicated	1	"#!/usr/bin/python<<NEWL>><<NEWL>>'''<<NEWL>>This example illustrates how to use Hough Transform to find lines<<NEWL>>'''<<NEWL>><<NEWL>># Python 2/3 compatibility<<NEWL>>from __future__ import print_function<<NEWL>><<NEWL>>import cv2 as cv<<NEWL>>import numpy as np<<NEWL>>import sys<<NEWL>>import math<<NEWL>><<NEWL>>from tests_common import NewOpenCVTests<<NEWL>><<NEWL>>def linesDiff(line1, line2):<<NEWL>><<NEWL>>    norm1 = cv.norm(line1 - line2, cv.NORM_L2)<<NEWL>>    line3 = line1[2:4] + line1[0:2]<<NEWL>>    norm2 = cv.norm(line3 - line2, cv.NORM_L2)<<NEWL>><<NEWL>>    return min(norm1, norm2)<<NEWL>><<NEWL>>class houghlines_test(NewOpenCVTests):<<NEWL>><<NEWL>>    def test_houghlines(self):<<NEWL>><<NEWL>>        fn = ""/samples/data/pic1.png""<<NEWL>><<NEWL>>        src = self.get_sample(fn)<<NEWL>>        dst = cv.Canny(src, 50, 200)<<NEWL>><<NEWL>>        lines = cv.HoughLinesP(dst, 1, math.pi/180.0, 40, np.array([]), 50, 10)[:,0,:]<<NEWL>><<NEWL>>        eps = 5<<NEWL>>        testLines = [<<NEWL>>            #rect1<<NEWL>>             [ 232,  25, 43, 25],<<NEWL>>             [ 43, 129, 232, 129],<<NEWL>>             [ 43, 129,  43,  25],<<NEWL>>             [232, 129, 232,  25],<<NEWL>>            #rect2<<NEWL>>             [251,  86, 314, 183],<<NEWL>>             [252,  86, 323,  40],<<NEWL>>             [315, 183, 386, 137],<<NEWL>>             [324,  40, 386, 136],<<NEWL>>            #triangle<<NEWL>>             [245, 205, 377, 205],<<NEWL>>             [244, 206, 305, 278],<<NEWL>>             [306, 279, 377, 205],<<NEWL>>            #rect3<<NEWL>>             [153, 177, 196, 177],<<NEWL>>             [153, 277, 153, 179],<<NEWL>>             [153, 277, 196, 277],<<NEWL>>             [196, 177, 196, 277]]<<NEWL>><<NEWL>>        matches_counter = 0<<NEWL>><<NEWL>>        for i in range(len(testLines)):<<NEWL>>            for j in range(len(lines)):<<NEWL>>                if linesDiff(testLines[i], lines[j]) < eps:<<NEWL>>                    matches_counter += 1<<NEWL>><<NEWL>>        self.assertGreater(float(matches_counter) / len(testLines), .7)<<NEWL>><<NEWL>>        lines_acc = cv.HoughLinesWithAccumulator(dst, rho=1, theta=np.pi / 180, threshold=150, srn=0, stn=0)<<NEWL>>        self.assertEqual(lines_acc[0,0,2], 192.0)<<NEWL>>        self.assertEqual(lines_acc[1,0,2], 187.0)<<NEWL>><<NEWL>>if __name__ == '__main__':<<NEWL>>    NewOpenCVTests.bootstrap()"
262	adjudicated	1	"import hashlib<<NEWL>>import hmac<<NEWL>>import re<<NEWL>>import time<<NEWL>>from binascii import a2b_hex<<NEWL>><<NEWL>><<NEWL>>AUTH_TOKEN_NAME = ""__cld_token__""<<NEWL>>AUTH_TOKEN_SEPARATOR = ""~""<<NEWL>>AUTH_TOKEN_UNSAFE_RE = r'([ ""#%&\'\/:;<=>?@\[\\\]^`{\|}~]+)'<<NEWL>><<NEWL>><<NEWL>>def generate(url=None, acl=None, start_time=None, duration=None,<<NEWL>>             expiration=None, ip=None, key=None, token_name=AUTH_TOKEN_NAME):<<NEWL>><<NEWL>>    if expiration is None:<<NEWL>>        if duration is not None:<<NEWL>>            start = start_time if start_time is not None else int(time.time())<<NEWL>>            expiration = start + duration<<NEWL>>        else:<<NEWL>>            raise Exception(""Must provide either expiration or duration"")<<NEWL>><<NEWL>>    if url is None and acl is None:<<NEWL>>        raise Exception(""Must provide either acl or url"")<<NEWL>><<NEWL>>    token_parts = []<<NEWL>>    if ip is not None:<<NEWL>>        token_parts.append(""ip="" + ip)<<NEWL>>    if start_time is not None:<<NEWL>>        token_parts.append(""st=%d"" % start_time)<<NEWL>>    token_parts.append(""exp=%d"" % expiration)<<NEWL>>    if acl is not None:<<NEWL>>        acl_list = acl if type(acl) is list else [acl]<<NEWL>>        acl_list = [_escape_to_lower(a) for a in acl_list] <<NEWL>>        token_parts.append(""acl=%s"" % ""!"".join(acl_list))<<NEWL>>    to_sign = list(token_parts)<<NEWL>>    if url is not None and acl is None:<<NEWL>>        to_sign.append(""url=%s"" % _escape_to_lower(url))<<NEWL>>    auth = _digest(AUTH_TOKEN_SEPARATOR.join(to_sign), key)<<NEWL>>    token_parts.append(""hmac=%s"" % auth)<<NEWL>>    return ""%(token_name)s=%(token)s"" % {""token_name"": token_name, ""token"": AUTH_TOKEN_SEPARATOR.join(token_parts)}<<NEWL>><<NEWL>><<NEWL>>def _digest(message, key):<<NEWL>>    bin_key = a2b_hex(key)<<NEWL>>    return hmac.new(bin_key, message.encode('utf-8'), hashlib.sha256).hexdigest()<<NEWL>><<NEWL>><<NEWL>>def _escape_to_lower(url):<<NEWL>>    # There is a circular import issue in this file, need to resolve it in the next major release<<NEWL>>    from cloudinary.utils import smart_escape<<NEWL>>    escaped_url = smart_escape(url, unsafe=AUTH_TOKEN_UNSAFE_RE)<<NEWL>>    escaped_url = re.sub(r""%[0-9A-F]{2}"", lambda x: x.group(0).lower(), escaped_url)<<NEWL>>    return escaped_url"
322	adjudicated	4	"""""""<<NEWL>>Mozilla Persona authentication backend, docs at:<<NEWL>>    https://python-social-auth.readthedocs.io/en/latest/backends/persona.html<<NEWL>>""""""<<NEWL>>from ..exceptions import AuthFailed, AuthMissingParameter<<NEWL>>from ..utils import handle_http_errors<<NEWL>>from .base import BaseAuth<<NEWL>><<NEWL>><<NEWL>>class PersonaAuth(BaseAuth):<<NEWL>>    """"""BrowserID authentication backend""""""<<NEWL>>    name = 'persona'<<NEWL>><<NEWL>>    def get_user_id(self, details, response):<<NEWL>>        """"""Use BrowserID email as ID""""""<<NEWL>>        return details['email']<<NEWL>><<NEWL>>    def get_user_details(self, response):<<NEWL>>        """"""Return user details, BrowserID only provides Email.""""""<<NEWL>>        # {'status': 'okay',<<NEWL>>        #  'audience': 'localhost:8000',<<NEWL>>        #  'expires': 1328983575529,<<NEWL>>        #  'email': 'name@server.com',<<NEWL>>        #  'issuer': 'browserid.org'}<<NEWL>>        email = response['email']<<NEWL>>        return {'username': email.split('@', 1)[0],<<NEWL>>                'email': email,<<NEWL>>                'fullname': '',<<NEWL>>                'first_name': '',<<NEWL>>                'last_name': ''}<<NEWL>><<NEWL>>    def extra_data(self, user, uid, response, details=None, *args, **kwargs):<<NEWL>>        """"""Return users extra data""""""<<NEWL>>        return {'audience': response['audience'],<<NEWL>>                'issuer': response['issuer']}<<NEWL>><<NEWL>>    @handle_http_errors<<NEWL>>    def auth_complete(self, *args, **kwargs):<<NEWL>>        """"""Completes login process, must return user instance""""""<<NEWL>>        if 'assertion' not in self.data:<<NEWL>>            raise AuthMissingParameter(self, 'assertion')<<NEWL>><<NEWL>>        response = self.get_json('https://browserid.org/verify', data={<<NEWL>>            'assertion': self.data['assertion'],<<NEWL>>            'audience': self.strategy.request_host()<<NEWL>>        }, method='POST')<<NEWL>>        if response.get('status') == 'failure':<<NEWL>>            raise AuthFailed(self)<<NEWL>>        kwargs.update({'response': response, 'backend': self})<<NEWL>>        return self.strategy.authenticate(*args, **kwargs)"
233	adjudicated	2	"import _plotly_utils.basevalidators<<NEWL>><<NEWL>><<NEWL>>class LineValidator(_plotly_utils.basevalidators.CompoundValidator):<<NEWL>>    def __init__(self, plotly_name=""line"", parent_name=""scatterternary"", **kwargs):<<NEWL>>        super(LineValidator, self).__init__(<<NEWL>>            plotly_name=plotly_name,<<NEWL>>            parent_name=parent_name,<<NEWL>>            data_class_str=kwargs.pop(""data_class_str"", ""Line""),<<NEWL>>            data_docs=kwargs.pop(<<NEWL>>                ""data_docs"",<<NEWL>>                """"""<<NEWL>>            backoff<<NEWL>>                Sets the line back off from the end point of<<NEWL>>                the nth line segment (in px). This option is<<NEWL>>                useful e.g. to avoid overlap with arrowhead<<NEWL>>                markers. With ""auto"" the lines would trim<<NEWL>>                before markers if `marker.angleref` is set to<<NEWL>>                ""previous"".<<NEWL>>            backoffsrc<<NEWL>>                Sets the source reference on Chart Studio Cloud<<NEWL>>                for `backoff`.<<NEWL>>            color<<NEWL>>                Sets the line color.<<NEWL>>            dash<<NEWL>>                Sets the dash style of lines. Set to a dash<<NEWL>>                type string (""solid"", ""dot"", ""dash"",<<NEWL>>                ""longdash"", ""dashdot"", or ""longdashdot"") or a<<NEWL>>                dash length list in px (eg ""5px,10px,2px,2px"").<<NEWL>>            shape<<NEWL>>                Determines the line shape. With ""spline"" the<<NEWL>>                lines are drawn using spline interpolation. The<<NEWL>>                other available values correspond to step-wise<<NEWL>>                line shapes.<<NEWL>>            smoothing<<NEWL>>                Has an effect only if `shape` is set to<<NEWL>>                ""spline"" Sets the amount of smoothing. 0<<NEWL>>                corresponds to no smoothing (equivalent to a<<NEWL>>                ""linear"" shape).<<NEWL>>            width<<NEWL>>                Sets the line width (in px).<<NEWL>>"""""",<<NEWL>>            ),<<NEWL>>            **kwargs,<<NEWL>>        )"
151	adjudicated	2	"import _plotly_utils.basevalidators<<NEWL>><<NEWL>><<NEWL>>class HoverlabelValidator(_plotly_utils.basevalidators.CompoundValidator):<<NEWL>>    def __init__(self, plotly_name=""hoverlabel"", parent_name=""heatmapgl"", **kwargs):<<NEWL>>        super(HoverlabelValidator, self).__init__(<<NEWL>>            plotly_name=plotly_name,<<NEWL>>            parent_name=parent_name,<<NEWL>>            data_class_str=kwargs.pop(""data_class_str"", ""Hoverlabel""),<<NEWL>>            data_docs=kwargs.pop(<<NEWL>>                ""data_docs"",<<NEWL>>                """"""<<NEWL>>            align<<NEWL>>                Sets the horizontal alignment of the text<<NEWL>>                content within hover label box. Has an effect<<NEWL>>                only if the hover label text spans more two or<<NEWL>>                more lines<<NEWL>>            alignsrc<<NEWL>>                Sets the source reference on Chart Studio Cloud<<NEWL>>                for `align`.<<NEWL>>            bgcolor<<NEWL>>                Sets the background color of the hover labels<<NEWL>>                for this trace<<NEWL>>            bgcolorsrc<<NEWL>>                Sets the source reference on Chart Studio Cloud<<NEWL>>                for `bgcolor`.<<NEWL>>            bordercolor<<NEWL>>                Sets the border color of the hover labels for<<NEWL>>                this trace.<<NEWL>>            bordercolorsrc<<NEWL>>                Sets the source reference on Chart Studio Cloud<<NEWL>>                for `bordercolor`.<<NEWL>>            font<<NEWL>>                Sets the font used in hover labels.<<NEWL>>            namelength<<NEWL>>                Sets the default length (in number of<<NEWL>>                characters) of the trace name in the hover<<NEWL>>                labels for all traces. -1 shows the whole name<<NEWL>>                regardless of length. 0-3 shows the first 0-3<<NEWL>>                characters, and an integer >3 will show the<<NEWL>>                whole name if it is less than that many<<NEWL>>                characters, but if it is longer, will truncate<<NEWL>>                to `namelength - 3` characters and add an<<NEWL>>                ellipsis.<<NEWL>>            namelengthsrc<<NEWL>>                Sets the source reference on Chart Studio Cloud<<NEWL>>                for `namelength`.<<NEWL>>"""""",<<NEWL>>            ),<<NEWL>>            **kwargs,<<NEWL>>        )"
380	adjudicated	0	######################## BEGIN LICENSE BLOCK ########################<<NEWL>># The Original Code is Mozilla Universal charset detector code.<<NEWL>>#<<NEWL>># The Initial Developer of the Original Code is<<NEWL>># Netscape Communications Corporation.<<NEWL>># Portions created by the Initial Developer are Copyright (C) 2001<<NEWL>># the Initial Developer. All Rights Reserved.<<NEWL>>#<<NEWL>># Contributor(s):<<NEWL>>#   Mark Pilgrim - port to Python<<NEWL>>#   Shy Shalom - original C code<<NEWL>>#   Proofpoint, Inc.<<NEWL>>#<<NEWL>># This library is free software; you can redistribute it and/or<<NEWL>># modify it under the terms of the GNU Lesser General Public<<NEWL>># License as published by the Free Software Foundation; either<<NEWL>># version 2.1 of the License, or (at your option) any later version.<<NEWL>>#<<NEWL>># This library is distributed in the hope that it will be useful,<<NEWL>># but WITHOUT ANY WARRANTY; without even the implied warranty of<<NEWL>># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU<<NEWL>># Lesser General Public License for more details.<<NEWL>>#<<NEWL>># You should have received a copy of the GNU Lesser General Public<<NEWL>># License along with this library; if not, write to the Free Software<<NEWL>># Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA<<NEWL>># 02110-1301  USA<<NEWL>>######################### END LICENSE BLOCK #########################<<NEWL>><<NEWL>>from .big5prober import Big5Prober<<NEWL>>from .charsetgroupprober import CharSetGroupProber<<NEWL>>from .cp949prober import CP949Prober<<NEWL>>from .enums import LanguageFilter<<NEWL>>from .eucjpprober import EUCJPProber<<NEWL>>from .euckrprober import EUCKRProber<<NEWL>>from .euctwprober import EUCTWProber<<NEWL>>from .gb2312prober import GB2312Prober<<NEWL>>from .johabprober import JOHABProber<<NEWL>>from .sjisprober import SJISProber<<NEWL>>from .utf8prober import UTF8Prober<<NEWL>><<NEWL>><<NEWL>>class MBCSGroupProber(CharSetGroupProber):<<NEWL>>    def __init__(self, lang_filter: LanguageFilter = LanguageFilter.NONE) -> None:<<NEWL>>        super().__init__(lang_filter=lang_filter)<<NEWL>>        self.probers = [<<NEWL>>            UTF8Prober(),<<NEWL>>            SJISProber(),<<NEWL>>            EUCJPProber(),<<NEWL>>            GB2312Prober(),<<NEWL>>            EUCKRProber(),<<NEWL>>            CP949Prober(),<<NEWL>>            Big5Prober(),<<NEWL>>            EUCTWProber(),<<NEWL>>            JOHABProber(),<<NEWL>>        ]<<NEWL>>        self.reset()
11	adjudicated	1	"""""""<<NEWL>>    pygments.lexers.capnproto<<NEWL>>    ~~~~~~~~~~~~~~~~~~~~~~~~~<<NEWL>><<NEWL>>    Lexers for the Cap'n Proto schema language.<<NEWL>><<NEWL>>    :copyright: Copyright 2006-2022 by the Pygments team, see AUTHORS.<<NEWL>>    :license: BSD, see LICENSE for details.<<NEWL>>""""""<<NEWL>><<NEWL>>from pygments.lexer import RegexLexer, default<<NEWL>>from pygments.token import Text, Comment, Keyword, Name, Literal, Whitespace<<NEWL>><<NEWL>>__all__ = ['CapnProtoLexer']<<NEWL>><<NEWL>><<NEWL>>class CapnProtoLexer(RegexLexer):<<NEWL>>    """"""<<NEWL>>    For Cap'n Proto source.<<NEWL>><<NEWL>>    .. versionadded:: 2.2<<NEWL>>    """"""<<NEWL>>    name = 'Cap\'n Proto'<<NEWL>>    url = 'https://capnproto.org'<<NEWL>>    filenames = ['*.capnp']<<NEWL>>    aliases = ['capnp']<<NEWL>><<NEWL>>    tokens = {<<NEWL>>        'root': [<<NEWL>>            (r'#.*?$', Comment.Single),<<NEWL>>            (r'@[0-9a-zA-Z]*', Name.Decorator),<<NEWL>>            (r'=', Literal, 'expression'),<<NEWL>>            (r':', Name.Class, 'type'),<<NEWL>>            (r'\$', Name.Attribute, 'annotation'),<<NEWL>>            (r'(struct|enum|interface|union|import|using|const|annotation|'<<NEWL>>             r'extends|in|of|on|as|with|from|fixed)\b',<<NEWL>>             Keyword),<<NEWL>>            (r'[\w.]+', Name),<<NEWL>>            (r'[^#@=:$\w\s]+', Text),<<NEWL>>            (r'\s+', Whitespace),<<NEWL>>        ],<<NEWL>>        'type': [<<NEWL>>            (r'[^][=;,(){}$]+', Name.Class),<<NEWL>>            (r'[\[(]', Name.Class, 'parentype'),<<NEWL>>            default('#pop'),<<NEWL>>        ],<<NEWL>>        'parentype': [<<NEWL>>            (r'[^][;()]+', Name.Class),<<NEWL>>            (r'[\[(]', Name.Class, '#push'),<<NEWL>>            (r'[])]', Name.Class, '#pop'),<<NEWL>>            default('#pop'),<<NEWL>>        ],<<NEWL>>        'expression': [<<NEWL>>            (r'[^][;,(){}$]+', Literal),<<NEWL>>            (r'[\[(]', Literal, 'parenexp'),<<NEWL>>            default('#pop'),<<NEWL>>        ],<<NEWL>>        'parenexp': [<<NEWL>>            (r'[^][;()]+', Literal),<<NEWL>>            (r'[\[(]', Literal, '#push'),<<NEWL>>            (r'[])]', Literal, '#pop'),<<NEWL>>            default('#pop'),<<NEWL>>        ],<<NEWL>>        'annotation': [<<NEWL>>            (r'[^][;,(){}=:]+', Name.Attribute),<<NEWL>>            (r'[\[(]', Name.Attribute, 'annexp'),<<NEWL>>            default('#pop'),<<NEWL>>        ],<<NEWL>>        'annexp': [<<NEWL>>            (r'[^][;()]+', Name.Attribute),<<NEWL>>            (r'[\[(]', Name.Attribute, '#push'),<<NEWL>>            (r'[])]', Name.Attribute, '#pop'),<<NEWL>>            default('#pop'),<<NEWL>>        ],<<NEWL>>    }"
291	adjudicated	4	"from django import template<<NEWL>>from django.contrib.admin.models import LogEntry<<NEWL>><<NEWL>>register = template.Library()<<NEWL>><<NEWL>><<NEWL>>class AdminLogNode(template.Node):<<NEWL>>    def __init__(self, limit, varname, user):<<NEWL>>        self.limit, self.varname, self.user = limit, varname, user<<NEWL>><<NEWL>>    def __repr__(self):<<NEWL>>        return ""<GetAdminLog Node>""<<NEWL>><<NEWL>>    def render(self, context):<<NEWL>>        if self.user is None:<<NEWL>>            entries = LogEntry.objects.all()<<NEWL>>        else:<<NEWL>>            user_id = self.user<<NEWL>>            if not user_id.isdigit():<<NEWL>>                user_id = context[self.user].pk<<NEWL>>            entries = LogEntry.objects.filter(user__pk=user_id)<<NEWL>>        context[self.varname] = entries.select_related('content_type', 'user')[:int(self.limit)]<<NEWL>>        return ''<<NEWL>><<NEWL>><<NEWL>>@register.tag<<NEWL>>def get_admin_log(parser, token):<<NEWL>>    """"""<<NEWL>>    Populate a template variable with the admin log for the given criteria.<<NEWL>><<NEWL>>    Usage::<<NEWL>><<NEWL>>        {% get_admin_log [limit] as [varname] for_user [context_var_containing_user_obj] %}<<NEWL>><<NEWL>>    Examples::<<NEWL>><<NEWL>>        {% get_admin_log 10 as admin_log for_user 23 %}<<NEWL>>        {% get_admin_log 10 as admin_log for_user user %}<<NEWL>>        {% get_admin_log 10 as admin_log %}<<NEWL>><<NEWL>>    Note that ``context_var_containing_user_obj`` can be a hard-coded integer<<NEWL>>    (user ID) or the name of a template context variable containing the user<<NEWL>>    object whose ID you want.<<NEWL>>    """"""<<NEWL>>    tokens = token.contents.split()<<NEWL>>    if len(tokens) < 4:<<NEWL>>        raise template.TemplateSyntaxError(<<NEWL>>            ""'get_admin_log' statements require two arguments"")<<NEWL>>    if not tokens[1].isdigit():<<NEWL>>        raise template.TemplateSyntaxError(<<NEWL>>            ""First argument to 'get_admin_log' must be an integer"")<<NEWL>>    if tokens[2] != 'as':<<NEWL>>        raise template.TemplateSyntaxError(<<NEWL>>            ""Second argument to 'get_admin_log' must be 'as'"")<<NEWL>>    if len(tokens) > 4:<<NEWL>>        if tokens[4] != 'for_user':<<NEWL>>            raise template.TemplateSyntaxError(<<NEWL>>                ""Fourth argument to 'get_admin_log' must be 'for_user'"")<<NEWL>>    return AdminLogNode(limit=tokens[1], varname=tokens[3], user=(tokens[5] if len(tokens) > 5 else None))"
100	adjudicated	2	"import _plotly_utils.basevalidators<<NEWL>><<NEWL>><<NEWL>>class HoverlabelValidator(_plotly_utils.basevalidators.CompoundValidator):<<NEWL>>    def __init__(self, plotly_name=""hoverlabel"", parent_name=""icicle"", **kwargs):<<NEWL>>        super(HoverlabelValidator, self).__init__(<<NEWL>>            plotly_name=plotly_name,<<NEWL>>            parent_name=parent_name,<<NEWL>>            data_class_str=kwargs.pop(""data_class_str"", ""Hoverlabel""),<<NEWL>>            data_docs=kwargs.pop(<<NEWL>>                ""data_docs"",<<NEWL>>                """"""<<NEWL>>            align<<NEWL>>                Sets the horizontal alignment of the text<<NEWL>>                content within hover label box. Has an effect<<NEWL>>                only if the hover label text spans more two or<<NEWL>>                more lines<<NEWL>>            alignsrc<<NEWL>>                Sets the source reference on Chart Studio Cloud<<NEWL>>                for `align`.<<NEWL>>            bgcolor<<NEWL>>                Sets the background color of the hover labels<<NEWL>>                for this trace<<NEWL>>            bgcolorsrc<<NEWL>>                Sets the source reference on Chart Studio Cloud<<NEWL>>                for `bgcolor`.<<NEWL>>            bordercolor<<NEWL>>                Sets the border color of the hover labels for<<NEWL>>                this trace.<<NEWL>>            bordercolorsrc<<NEWL>>                Sets the source reference on Chart Studio Cloud<<NEWL>>                for `bordercolor`.<<NEWL>>            font<<NEWL>>                Sets the font used in hover labels.<<NEWL>>            namelength<<NEWL>>                Sets the default length (in number of<<NEWL>>                characters) of the trace name in the hover<<NEWL>>                labels for all traces. -1 shows the whole name<<NEWL>>                regardless of length. 0-3 shows the first 0-3<<NEWL>>                characters, and an integer >3 will show the<<NEWL>>                whole name if it is less than that many<<NEWL>>                characters, but if it is longer, will truncate<<NEWL>>                to `namelength - 3` characters and add an<<NEWL>>                ellipsis.<<NEWL>>            namelengthsrc<<NEWL>>                Sets the source reference on Chart Studio Cloud<<NEWL>>                for `namelength`.<<NEWL>>"""""",<<NEWL>>            ),<<NEWL>>            **kwargs,<<NEWL>>        )"
40	adjudicated	1	"# -*- coding: utf-8 -*-<<NEWL>># Generated by the protocol buffer compiler.  DO NOT EDIT!<<NEWL>># source: streamlit/proto/Favicon.proto<<NEWL>><<NEWL>>from google.protobuf import descriptor as _descriptor<<NEWL>>from google.protobuf import message as _message<<NEWL>>from google.protobuf import reflection as _reflection<<NEWL>>from google.protobuf import symbol_database as _symbol_database<<NEWL>># @@protoc_insertion_point(imports)<<NEWL>><<NEWL>>_sym_db = _symbol_database.Default()<<NEWL>><<NEWL>><<NEWL>><<NEWL>><<NEWL>>DESCRIPTOR = _descriptor.FileDescriptor(<<NEWL>>  name='streamlit/proto/Favicon.proto',<<NEWL>>  package='',<<NEWL>>  syntax='proto3',<<NEWL>>  serialized_options=None,<<NEWL>>  create_key=_descriptor._internal_create_key,<<NEWL>>  serialized_pb=b'\n\x1dstreamlit/proto/Favicon.proto\""\x16\n\x07\x46\x61vicon\x12\x0b\n\x03url\x18\x01 \x01(\tb\x06proto3'<<NEWL>>)<<NEWL>><<NEWL>><<NEWL>><<NEWL>><<NEWL>>_FAVICON = _descriptor.Descriptor(<<NEWL>>  name='Favicon',<<NEWL>>  full_name='Favicon',<<NEWL>>  filename=None,<<NEWL>>  file=DESCRIPTOR,<<NEWL>>  containing_type=None,<<NEWL>>  create_key=_descriptor._internal_create_key,<<NEWL>>  fields=[<<NEWL>>    _descriptor.FieldDescriptor(<<NEWL>>      name='url', full_name='Favicon.url', index=0,<<NEWL>>      number=1, type=9, cpp_type=9, label=1,<<NEWL>>      has_default_value=False, default_value=b"""".decode('utf-8'),<<NEWL>>      message_type=None, enum_type=None, containing_type=None,<<NEWL>>      is_extension=False, extension_scope=None,<<NEWL>>      serialized_options=None, file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),<<NEWL>>  ],<<NEWL>>  extensions=[<<NEWL>>  ],<<NEWL>>  nested_types=[],<<NEWL>>  enum_types=[<<NEWL>>  ],<<NEWL>>  serialized_options=None,<<NEWL>>  is_extendable=False,<<NEWL>>  syntax='proto3',<<NEWL>>  extension_ranges=[],<<NEWL>>  oneofs=[<<NEWL>>  ],<<NEWL>>  serialized_start=33,<<NEWL>>  serialized_end=55,<<NEWL>>)<<NEWL>><<NEWL>>DESCRIPTOR.message_types_by_name['Favicon'] = _FAVICON<<NEWL>>_sym_db.RegisterFileDescriptor(DESCRIPTOR)<<NEWL>><<NEWL>>Favicon = _reflection.GeneratedProtocolMessageType('Favicon', (_message.Message,), {<<NEWL>>  'DESCRIPTOR' : _FAVICON,<<NEWL>>  '__module__' : 'streamlit.proto.Favicon_pb2'<<NEWL>>  # @@protoc_insertion_point(class_scope:Favicon)<<NEWL>>  })<<NEWL>>_sym_db.RegisterMessage(Favicon)<<NEWL>><<NEWL>><<NEWL>># @@protoc_insertion_point(module_scope)"
